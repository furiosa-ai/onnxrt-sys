/* automatically generated by rust-bindgen 0.69.4 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const ORT_API_VERSION: u32 = 17;
pub const __SAL_H_FULL_VER: u32 = 140050727;
pub const __SPECSTRINGS_STRICT_LEVEL: u32 = 1;
pub const __drv_typeConst: u32 = 0;
pub const __drv_typeCond: u32 = 1;
pub const __drv_typeBitset: u32 = 2;
pub const __drv_typeExpr: u32 = 3;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__crt_locale_pointers), "::", stringify!(locinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(__crt_locale_pointers), "::", stringify!(mbcinfo))
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_Mbstatet), "::", stringify!(_Wchar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_Mbstatet), "::", stringify!(_Byte))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!("Offset of field: ", stringify!(_Mbstatet), "::", stringify!(_State))
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(::std::mem::size_of::<_div_t>(), 8usize, concat!("Size of: ", stringify!(_div_t)));
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_div_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_div_t), "::", stringify!(rem))
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(::std::mem::size_of::<_ldiv_t>(), 8usize, concat!("Size of: ", stringify!(_ldiv_t)));
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_ldiv_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_ldiv_t), "::", stringify!(rem))
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_lldiv_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_lldiv_t), "::", stringify!(rem))
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LDOUBLE), "::", stringify!(ld))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_CRT_DOUBLE), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_CRT_FLOAT), "::", stringify!(f))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LONGDOUBLE), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LDBL12), "::", stringify!(ld12))
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(i32)]
#[doc = " Copied from TensorProto::DataType\n Currently, Ort doesn't support complex64, complex128"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ONNXTensorElementDataType {
    ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED = 0,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT = 1,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8 = 2,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8 = 3,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16 = 4,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16 = 5,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32 = 6,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64 = 7,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING = 8,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL = 9,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16 = 10,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE = 11,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32 = 12,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64 = 13,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64 = 14,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128 = 15,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16 = 16,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN = 17,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ = 18,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2 = 19,
    ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ = 20,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ONNXType {
    ONNX_TYPE_UNKNOWN = 0,
    ONNX_TYPE_TENSOR = 1,
    ONNX_TYPE_SEQUENCE = 2,
    ONNX_TYPE_MAP = 3,
    ONNX_TYPE_OPAQUE = 4,
    ONNX_TYPE_SPARSETENSOR = 5,
    ONNX_TYPE_OPTIONAL = 6,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtSparseFormat {
    ORT_SPARSE_UNDEFINED = 0,
    ORT_SPARSE_COO = 1,
    ORT_SPARSE_CSRC = 2,
    ORT_SPARSE_BLOCK_SPARSE = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtSparseIndicesFormat {
    ORT_SPARSE_COO_INDICES = 0,
    ORT_SPARSE_CSR_INNER_INDICES = 1,
    ORT_SPARSE_CSR_OUTER_INDICES = 2,
    ORT_SPARSE_BLOCK_SPARSE_INDICES = 3,
}
#[repr(i32)]
#[doc = " \\brief Logging severity levels\n\n In typical API usage, specifying a logging severity level specifies the minimum severity of log messages to show."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtLoggingLevel {
    #[doc = "< Verbose informational messages (least severe)."]
    ORT_LOGGING_LEVEL_VERBOSE = 0,
    #[doc = "< Informational messages."]
    ORT_LOGGING_LEVEL_INFO = 1,
    #[doc = "< Warning messages."]
    ORT_LOGGING_LEVEL_WARNING = 2,
    #[doc = "< Error messages."]
    ORT_LOGGING_LEVEL_ERROR = 3,
    #[doc = "< Fatal error messages (most severe)."]
    ORT_LOGGING_LEVEL_FATAL = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtErrorCode {
    ORT_OK = 0,
    ORT_FAIL = 1,
    ORT_INVALID_ARGUMENT = 2,
    ORT_NO_SUCHFILE = 3,
    ORT_NO_MODEL = 4,
    ORT_ENGINE_ERROR = 5,
    ORT_RUNTIME_EXCEPTION = 6,
    ORT_INVALID_PROTOBUF = 7,
    ORT_MODEL_LOADED = 8,
    ORT_NOT_IMPLEMENTED = 9,
    ORT_INVALID_GRAPH = 10,
    ORT_EP_FAIL = 11,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtOpAttrType {
    ORT_OP_ATTR_UNDEFINED = 0,
    ORT_OP_ATTR_INT = 1,
    ORT_OP_ATTR_INTS = 2,
    ORT_OP_ATTR_FLOAT = 3,
    ORT_OP_ATTR_FLOATS = 4,
    ORT_OP_ATTR_STRING = 5,
    ORT_OP_ATTR_STRINGS = 6,
}
#[doc = " \\addtogroup Global\n ONNX Runtime C API\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtEnv {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtStatus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtMemoryInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtIoBinding {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtSession {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtValue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtRunOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtTypeInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtTensorTypeAndShapeInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtMapTypeInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtSequenceTypeInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtOptionalTypeInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtSessionOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtCustomOpDomain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtModelMetadata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtThreadPoolParams {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtThreadingOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtArenaCfg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtPrepackedWeightsContainer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtTensorRTProviderOptionsV2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtCUDAProviderOptionsV2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtCANNProviderOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtDnnlProviderOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtOp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtOpAttr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtLogger {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtShapeInferContext {
    _unused: [u8; 0],
}
pub type OrtStatusPtr = *mut OrtStatus;
#[doc = " \\brief Memory allocation interface\n\n Structure of function pointers that defines a memory allocator. This can be created and filled in by the user for custom allocators.\n\n When an allocator is passed to any function, be sure that the allocator object is not destroyed until the last allocated object using it is freed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtAllocator {
    #[doc = "< Must be initialized to ORT_API_VERSION"]
    pub version: u32,
    #[doc = "< Returns a pointer to an allocated block of `size` bytes"]
    pub Alloc: ::std::option::Option<
        unsafe extern "C" fn(this_: *mut OrtAllocator, size: usize) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = "< Free a block of memory previously allocated with OrtAllocator::Alloc"]
    pub Free: ::std::option::Option<
        unsafe extern "C" fn(this_: *mut OrtAllocator, p: *mut ::std::os::raw::c_void),
    >,
    #[doc = "< Return a pointer to an ::OrtMemoryInfo that describes this allocator"]
    pub Info: ::std::option::Option<
        unsafe extern "C" fn(this_: *const OrtAllocator) -> *const OrtMemoryInfo,
    >,
}
#[test]
fn bindgen_test_layout_OrtAllocator() {
    const UNINIT: ::std::mem::MaybeUninit<OrtAllocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtAllocator>(),
        32usize,
        concat!("Size of: ", stringify!(OrtAllocator))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(OrtAllocator), "::", stringify!(version))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Alloc) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(OrtAllocator), "::", stringify!(Alloc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Free) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(OrtAllocator), "::", stringify!(Free))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Info) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(OrtAllocator), "::", stringify!(Info))
    );
}
pub type OrtLoggingFunction = ::std::option::Option<
    unsafe extern "C" fn(
        param: *mut ::std::os::raw::c_void,
        severity: OrtLoggingLevel,
        category: *const ::std::os::raw::c_char,
        logid: *const ::std::os::raw::c_char,
        code_location: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    ),
>;
#[repr(i32)]
#[doc = " \\brief Graph optimization level\n\n Refer to https://www.onnxruntime.ai/docs/performance/graph-optimizations.html#graph-optimization-levels\n for an in-depth understanding of the Graph Optimization Levels."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GraphOptimizationLevel {
    ORT_DISABLE_ALL = 0,
    ORT_ENABLE_BASIC = 1,
    ORT_ENABLE_EXTENDED = 2,
    ORT_ENABLE_ALL = 99,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ExecutionMode {
    ORT_SEQUENTIAL = 0,
    ORT_PARALLEL = 1,
}
#[repr(i32)]
#[doc = " \\brief Language projection identifiers\n /see OrtApi::SetLanguageProjection"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtLanguageProjection {
    ORT_PROJECTION_C = 0,
    ORT_PROJECTION_CPLUSPLUS = 1,
    ORT_PROJECTION_CSHARP = 2,
    ORT_PROJECTION_PYTHON = 3,
    ORT_PROJECTION_JAVA = 4,
    ORT_PROJECTION_WINML = 5,
    ORT_PROJECTION_NODEJS = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtKernelInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtKernelContext {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtAllocatorType {
    OrtInvalidAllocator = -1,
    OrtDeviceAllocator = 0,
    OrtArenaAllocator = 1,
}
impl OrtMemType {
    pub const OrtMemTypeCPU: OrtMemType = OrtMemType::OrtMemTypeCPUOutput;
}
#[repr(i32)]
#[doc = " \\brief Memory types for allocated memory, execution provider specific types should be extended in each provider."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtMemType {
    #[doc = "< Any CPU memory used by non-CPU execution provider"]
    OrtMemTypeCPUInput = -2,
    #[doc = "< CPU accessible memory outputted by non-CPU execution provider, i.e. CUDA_PINNED"]
    OrtMemTypeCPUOutput = -1,
    #[doc = "< The default allocator for execution provider"]
    OrtMemTypeDefault = 0,
}
#[repr(i32)]
#[doc = " \\brief This mimics OrtDevice type constants so they can be returned in the API"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtMemoryInfoDeviceType {
    OrtMemoryInfoDeviceType_CPU = 0,
    OrtMemoryInfoDeviceType_GPU = 1,
    OrtMemoryInfoDeviceType_FPGA = 2,
}
#[repr(i32)]
#[doc = " \\brief Algorithm to use for cuDNN Convolution Op"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtCudnnConvAlgoSearch {
    OrtCudnnConvAlgoSearchExhaustive = 0,
    OrtCudnnConvAlgoSearchHeuristic = 1,
    OrtCudnnConvAlgoSearchDefault = 2,
}
#[doc = " \\brief CUDA Provider Options\n\n \\see OrtApi::SessionOptionsAppendExecutionProvider_CUDA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtCUDAProviderOptions {
    #[doc = " \\brief CUDA device Id\n   Defaults to 0."]
    pub device_id: ::std::os::raw::c_int,
    #[doc = " \\brief CUDA Convolution algorithm search configuration.\n   See enum OrtCudnnConvAlgoSearch for more details.\n   Defaults to OrtCudnnConvAlgoSearchExhaustive."]
    pub cudnn_conv_algo_search: OrtCudnnConvAlgoSearch,
    #[doc = " \\brief CUDA memory limit (To use all possible memory pass in maximum size_t)\n   Defaults to SIZE_MAX.\n   \\note If a ::OrtArenaCfg has been applied, it will override this field"]
    pub gpu_mem_limit: usize,
    #[doc = " \\brief Strategy used to grow the memory arena\n   0 = kNextPowerOfTwo<br>\n   1 = kSameAsRequested<br>\n   Defaults to 0.\n   \\note If a ::OrtArenaCfg has been applied, it will override this field"]
    pub arena_extend_strategy: ::std::os::raw::c_int,
    #[doc = " \\brief Flag indicating if copying needs to take place on the same stream as the compute stream in the CUDA EP\n   0 = Use separate streams for copying and compute.\n   1 = Use the same stream for copying and compute.\n   Defaults to 1.\n   WARNING: Setting this to 0 may result in data races for some models.\n   Please see issue #4829 for more details."]
    pub do_copy_in_default_stream: ::std::os::raw::c_int,
    #[doc = " \\brief Flag indicating if there is a user provided compute stream\n   Defaults to 0."]
    pub has_user_compute_stream: ::std::os::raw::c_int,
    #[doc = " \\brief User provided compute stream.\n   If provided, please set `has_user_compute_stream` to 1."]
    pub user_compute_stream: *mut ::std::os::raw::c_void,
    #[doc = " \\brief CUDA memory arena configuration parameters"]
    pub default_memory_arena_cfg: *mut OrtArenaCfg,
    #[doc = " \\brief Enable TunableOp for using.\n   Set it to 1/0 to enable/disable TunableOp. Otherwise, it is disabled by default.\n   This option can be overriden by environment variable ORT_CUDA_TUNABLE_OP_ENABLE."]
    pub tunable_op_enable: ::std::os::raw::c_int,
    #[doc = " \\brief Enable TunableOp for tuning.\n   Set it to 1/0 to enable/disable TunableOp tuning. Otherwise, it is disabled by default.\n   This option can be overriden by environment variable ORT_CUDA_TUNABLE_OP_TUNING_ENABLE."]
    pub tunable_op_tuning_enable: ::std::os::raw::c_int,
    #[doc = " \\brief Max tuning duration time limit for each instance of TunableOp.\n   Defaults to 0 to disable the limit."]
    pub tunable_op_max_tuning_duration_ms: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OrtCUDAProviderOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OrtCUDAProviderOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtCUDAProviderOptions>(),
        64usize,
        concat!("Size of: ", stringify!(OrtCUDAProviderOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtCUDAProviderOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtCUDAProviderOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cudnn_conv_algo_search) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(cudnn_conv_algo_search)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_mem_limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(gpu_mem_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arena_extend_strategy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(arena_extend_strategy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_copy_in_default_stream) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(do_copy_in_default_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_user_compute_stream) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(has_user_compute_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_compute_stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(user_compute_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_memory_arena_cfg) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(default_memory_arena_cfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunable_op_enable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(tunable_op_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunable_op_tuning_enable) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(tunable_op_tuning_enable)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tunable_op_max_tuning_duration_ms) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCUDAProviderOptions),
            "::",
            stringify!(tunable_op_max_tuning_duration_ms)
        )
    );
}
#[doc = " \\brief ROCM Provider Options\n\n \\see OrtApi::SessionOptionsAppendExecutionProvider_ROCM"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtROCMProviderOptions {
    #[doc = " \\brief ROCM device Id\n   Defaults to 0."]
    pub device_id: ::std::os::raw::c_int,
    #[doc = " \\brief ROCM MIOpen Convolution algorithm exaustive search option.\n   Defaults to 0 (false)."]
    pub miopen_conv_exhaustive_search: ::std::os::raw::c_int,
    #[doc = " \\brief ROCM memory limit (To use all possible memory pass in maximum size_t)\n   Defaults to SIZE_MAX.\n   \\note If a ::OrtArenaCfg has been applied, it will override this field"]
    pub gpu_mem_limit: usize,
    #[doc = " \\brief Strategy used to grow the memory arena\n   0 = kNextPowerOfTwo<br>\n   1 = kSameAsRequested<br>\n   Defaults to 0.\n   \\note If a ::OrtArenaCfg has been applied, it will override this field"]
    pub arena_extend_strategy: ::std::os::raw::c_int,
    #[doc = " \\brief Flag indicating if copying needs to take place on the same stream as the compute stream in the ROCM EP\n   0 = Use separate streams for copying and compute.\n   1 = Use the same stream for copying and compute.\n   Defaults to 1.\n   WARNING: Setting this to 0 may result in data races for some models.\n   Please see issue #4829 for more details."]
    pub do_copy_in_default_stream: ::std::os::raw::c_int,
    #[doc = " \\brief Flag indicating if there is a user provided compute stream\n   Defaults to 0."]
    pub has_user_compute_stream: ::std::os::raw::c_int,
    #[doc = " \\brief User provided compute stream.\n   If provided, please set `has_user_compute_stream` to 1."]
    pub user_compute_stream: *mut ::std::os::raw::c_void,
    #[doc = " \\brief ROCM memory arena configuration parameters"]
    pub default_memory_arena_cfg: *mut OrtArenaCfg,
    #[doc = " \\brief Enable TunableOp for using.\n   Set it to 1/0 to enable/disable TunableOp. Otherwise, it is disabled by default.\n   This option can be overriden by environment variable ORT_ROCM_TUNABLE_OP_ENABLE."]
    pub tunable_op_enable: ::std::os::raw::c_int,
    #[doc = " \\brief Enable TunableOp for tuning.\n   Set it to 1/0 to enable/disable TunableOp tuning. Otherwise, it is disabled by default.\n   This option can be overriden by environment variable ORT_ROCM_TUNABLE_OP_TUNING_ENABLE."]
    pub tunable_op_tuning_enable: ::std::os::raw::c_int,
    #[doc = " \\brief Max tuning duration time limit for each instance of TunableOp.\n   Defaults to 0 to disable the limit."]
    pub tunable_op_max_tuning_duration_ms: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OrtROCMProviderOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OrtROCMProviderOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtROCMProviderOptions>(),
        64usize,
        concat!("Size of: ", stringify!(OrtROCMProviderOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtROCMProviderOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtROCMProviderOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).miopen_conv_exhaustive_search) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(miopen_conv_exhaustive_search)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpu_mem_limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(gpu_mem_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arena_extend_strategy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(arena_extend_strategy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_copy_in_default_stream) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(do_copy_in_default_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_user_compute_stream) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(has_user_compute_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_compute_stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(user_compute_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_memory_arena_cfg) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(default_memory_arena_cfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunable_op_enable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(tunable_op_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunable_op_tuning_enable) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(tunable_op_tuning_enable)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tunable_op_max_tuning_duration_ms) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtROCMProviderOptions),
            "::",
            stringify!(tunable_op_max_tuning_duration_ms)
        )
    );
}
#[doc = " \\brief TensorRT Provider Options\n\n \\see OrtApi::SessionOptionsAppendExecutionProvider_TensorRT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtTensorRTProviderOptions {
    #[doc = "< CUDA device id (0 = default device)"]
    pub device_id: ::std::os::raw::c_int,
    pub has_user_compute_stream: ::std::os::raw::c_int,
    pub user_compute_stream: *mut ::std::os::raw::c_void,
    pub trt_max_partition_iterations: ::std::os::raw::c_int,
    pub trt_min_subgraph_size: ::std::os::raw::c_int,
    pub trt_max_workspace_size: usize,
    pub trt_fp16_enable: ::std::os::raw::c_int,
    pub trt_int8_enable: ::std::os::raw::c_int,
    pub trt_int8_calibration_table_name: *const ::std::os::raw::c_char,
    pub trt_int8_use_native_calibration_table: ::std::os::raw::c_int,
    pub trt_dla_enable: ::std::os::raw::c_int,
    pub trt_dla_core: ::std::os::raw::c_int,
    pub trt_dump_subgraphs: ::std::os::raw::c_int,
    pub trt_engine_cache_enable: ::std::os::raw::c_int,
    pub trt_engine_cache_path: *const ::std::os::raw::c_char,
    pub trt_engine_decryption_enable: ::std::os::raw::c_int,
    pub trt_engine_decryption_lib_path: *const ::std::os::raw::c_char,
    pub trt_force_sequential_engine_build: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OrtTensorRTProviderOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OrtTensorRTProviderOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtTensorRTProviderOptions>(),
        104usize,
        concat!("Size of: ", stringify!(OrtTensorRTProviderOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtTensorRTProviderOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtTensorRTProviderOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_user_compute_stream) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(has_user_compute_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_compute_stream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(user_compute_stream)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).trt_max_partition_iterations) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_max_partition_iterations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_min_subgraph_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_min_subgraph_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_max_workspace_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_max_workspace_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_fp16_enable) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_fp16_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_int8_enable) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_int8_enable)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).trt_int8_calibration_table_name) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_int8_calibration_table_name)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).trt_int8_use_native_calibration_table) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_int8_use_native_calibration_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_dla_enable) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_dla_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_dla_core) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_dla_core)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_dump_subgraphs) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_dump_subgraphs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_engine_cache_enable) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_engine_cache_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trt_engine_cache_path) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_engine_cache_path)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).trt_engine_decryption_enable) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_engine_decryption_enable)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).trt_engine_decryption_lib_path) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_engine_decryption_lib_path)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).trt_force_sequential_engine_build) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtTensorRTProviderOptions),
            "::",
            stringify!(trt_force_sequential_engine_build)
        )
    );
}
#[doc = " \\brief MIGraphX Provider Options\n\n \\see OrtApi::SessionOptionsAppendExecutionProvider_MIGraphX"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtMIGraphXProviderOptions {
    pub device_id: ::std::os::raw::c_int,
    pub migraphx_fp16_enable: ::std::os::raw::c_int,
    pub migraphx_int8_enable: ::std::os::raw::c_int,
    pub migraphx_use_native_calibration_table: ::std::os::raw::c_int,
    pub migraphx_int8_calibration_table_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_OrtMIGraphXProviderOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OrtMIGraphXProviderOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtMIGraphXProviderOptions>(),
        24usize,
        concat!("Size of: ", stringify!(OrtMIGraphXProviderOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtMIGraphXProviderOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtMIGraphXProviderOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtMIGraphXProviderOptions),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).migraphx_fp16_enable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtMIGraphXProviderOptions),
            "::",
            stringify!(migraphx_fp16_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).migraphx_int8_enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtMIGraphXProviderOptions),
            "::",
            stringify!(migraphx_int8_enable)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).migraphx_use_native_calibration_table) as usize
                - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtMIGraphXProviderOptions),
            "::",
            stringify!(migraphx_use_native_calibration_table)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).migraphx_int8_calibration_table_name) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtMIGraphXProviderOptions),
            "::",
            stringify!(migraphx_int8_calibration_table_name)
        )
    );
}
#[doc = " \\brief OpenVINO Provider Options\n\n \\see OrtApi::SessionOptionsAppendExecutionProvider_OpenVINO"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtOpenVINOProviderOptions {
    #[doc = " \\brief Device type string\n\n Valid settings are one of: \"CPU_FP32\", \"CPU_FP16\", \"GPU_FP32\", \"GPU_FP16\""]
    pub device_type: *const ::std::os::raw::c_char,
    #[doc = "< 0 = disabled, nonzero = enabled"]
    pub enable_npu_fast_compile: ::std::os::raw::c_uchar,
    pub device_id: *const ::std::os::raw::c_char,
    #[doc = "< 0 = Use default number of threads"]
    pub num_of_threads: usize,
    pub cache_dir: *const ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_void,
    #[doc = "< 0 = disabled, nonzero = enabled"]
    pub enable_opencl_throttling: ::std::os::raw::c_uchar,
    #[doc = "< 0 = disabled, nonzero = enabled"]
    pub enable_dynamic_shapes: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_OrtOpenVINOProviderOptions() {
    const UNINIT: ::std::mem::MaybeUninit<OrtOpenVINOProviderOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtOpenVINOProviderOptions>(),
        56usize,
        concat!("Size of: ", stringify!(OrtOpenVINOProviderOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtOpenVINOProviderOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtOpenVINOProviderOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtOpenVINOProviderOptions),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_npu_fast_compile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtOpenVINOProviderOptions),
            "::",
            stringify!(enable_npu_fast_compile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtOpenVINOProviderOptions),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_of_threads) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtOpenVINOProviderOptions),
            "::",
            stringify!(num_of_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_dir) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtOpenVINOProviderOptions),
            "::",
            stringify!(cache_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtOpenVINOProviderOptions),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_opencl_throttling) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtOpenVINOProviderOptions),
            "::",
            stringify!(enable_opencl_throttling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_dynamic_shapes) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtOpenVINOProviderOptions),
            "::",
            stringify!(enable_dynamic_shapes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtTrainingApi {
    _unused: [u8; 0],
}
#[doc = " \\brief The helper interface to get the right version of OrtApi\n\n Get a pointer to this structure through ::OrtGetApiBase"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtApiBase {
    #[doc = " \\brief Get a pointer to the requested version of the ::OrtApi\n\n \\param[in] version Must be ::ORT_API_VERSION\n \\return The ::OrtApi for the version requested, nullptr will be returned if this version is unsupported, for example when using a runtime\n   older than the version created with this header file.\n\n One can call GetVersionString() to get the version of the Onnxruntime library for logging\n and error reporting purposes."]
    pub GetApi: ::std::option::Option<unsafe extern "C" fn(version: u32) -> *const OrtApi>,
    #[doc = " \\brief Returns a null terminated string of the version of the Onnxruntime library (eg: \"1.8.1\")\n\n  \\return UTF-8 encoded version string. Do not deallocate the returned buffer."]
    pub GetVersionString:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_OrtApiBase() {
    const UNINIT: ::std::mem::MaybeUninit<OrtApiBase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtApiBase>(),
        16usize,
        concat!("Size of: ", stringify!(OrtApiBase))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtApiBase>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtApiBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetApi) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(OrtApiBase), "::", stringify!(GetApi))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetVersionString) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(OrtApiBase), "::", stringify!(GetVersionString))
    );
}
extern "C" {
    #[doc = " \\brief The Onnxruntime library's entry point to access the C API\n\n Call this to get the a pointer to an ::OrtApiBase"]
    pub fn OrtGetApiBase() -> *const OrtApiBase;
}
#[doc = " \\brief Thread work loop function\n\n Onnxruntime will provide the working loop on custom thread creation\n Argument is an onnxruntime built-in type which will be provided when thread pool calls OrtCustomCreateThreadFn"]
pub type OrtThreadWorkerFn =
    ::std::option::Option<unsafe extern "C" fn(ort_worker_fn_param: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtCustomHandleType {
    pub __place_holder: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_OrtCustomHandleType() {
    const UNINIT: ::std::mem::MaybeUninit<OrtCustomHandleType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtCustomHandleType>(),
        1usize,
        concat!("Size of: ", stringify!(OrtCustomHandleType))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtCustomHandleType>(),
        1usize,
        concat!("Alignment of ", stringify!(OrtCustomHandleType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__place_holder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCustomHandleType),
            "::",
            stringify!(__place_holder)
        )
    );
}
pub type OrtCustomThreadHandle = *const OrtCustomHandleType;
#[doc = " \\brief Ort custom thread creation function\n\n The function should return a thread handle to be used in onnxruntime thread pools\n Onnxruntime will throw exception on return value of nullptr or 0, indicating that the function failed to create a thread"]
pub type OrtCustomCreateThreadFn = ::std::option::Option<
    unsafe extern "C" fn(
        ort_custom_thread_creation_options: *mut ::std::os::raw::c_void,
        ort_thread_worker_fn: OrtThreadWorkerFn,
        ort_worker_fn_param: *mut ::std::os::raw::c_void,
    ) -> OrtCustomThreadHandle,
>;
#[doc = " \\brief Custom thread join function\n\n Onnxruntime thread pool destructor will call the function to join a custom thread.\n Argument ort_custom_thread_handle is the value returned by OrtCustomCreateThreadFn"]
pub type OrtCustomJoinThreadFn =
    ::std::option::Option<unsafe extern "C" fn(ort_custom_thread_handle: OrtCustomThreadHandle)>;
pub type RegisterCustomOpsFn = ::std::option::Option<
    unsafe extern "C" fn(options: *mut OrtSessionOptions, api: *const OrtApiBase) -> *mut OrtStatus,
>;
#[doc = " \\brief Callback function for RunAsync\n\n \\param[in] user_data User specific data that passed back to the callback\n \\param[out] outputs On succeed, outputs host inference results, on error, the value will be nullptr\n \\param[out] num_outputs Number of outputs, on error, the value will be zero\n \\param[out] status On error, status will provide details"]
pub type RunAsyncCallbackFn = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        outputs: *mut *mut OrtValue,
        num_outputs: usize,
        status: OrtStatusPtr,
    ),
>;
#[doc = " \\brief The C API\n\n All C API functions are defined inside this structure as pointers to functions.\n Call OrtApiBase::GetApi to get a pointer to it\n\n \\nosubgrouping"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtApi {
    #[doc = " \\brief Create an OrtStatus from a null terminated string\n\n \\param[in] code\n \\param[in] msg A null-terminated string. Its contents will be copied.\n \\return A new OrtStatus object, must be destroyed with OrtApi::ReleaseStatus"]
    pub CreateStatus: ::std::option::Option<
        unsafe extern "C" fn(
            code: OrtErrorCode,
            msg: *const ::std::os::raw::c_char,
        ) -> *mut OrtStatus,
    >,
    #[doc = " \\brief Get OrtErrorCode from OrtStatus\n\n \\param[in] status\n \\return OrtErrorCode that \\p status was created with"]
    pub GetErrorCode:
        ::std::option::Option<unsafe extern "C" fn(status: *const OrtStatus) -> OrtErrorCode>,
    #[doc = " \\brief Get error string from OrtStatus\n\n \\param[in] status\n \\return The error message inside the `status`. Do not free the returned value."]
    pub GetErrorMessage: ::std::option::Option<
        unsafe extern "C" fn(status: *const OrtStatus) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " \\brief Create an OrtEnv\n\n \\note Invoking this function will return the same instance of the environment as that returned by a previous call\n to another env creation function; all arguments to this function will be ignored.\n \\param[in] log_severity_level The log severity level.\n \\param[in] logid The log identifier.\n \\param[out] out Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateEnv: ::std::option::Option<
        unsafe extern "C" fn(
            log_severity_level: OrtLoggingLevel,
            logid: *const ::std::os::raw::c_char,
            out: *mut *mut OrtEnv,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an OrtEnv\n\n \\note Invoking this function will return the same instance of the environment as that returned by a previous call\n to another env creation function; all arguments to this function will be ignored. If you want to provide your\n own logging function, consider setting it using the SetUserLoggingFunction API instead.\n \\param[in] logging_function A pointer to a logging function.\n \\param[in] logger_param A pointer to arbitrary data passed as the ::OrtLoggingFunction `param` parameter to\n                         `logging_function`. This parameter is optional.\n \\param[in] log_severity_level The log severity level.\n \\param[in] logid The log identifier.\n \\param[out] out Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateEnvWithCustomLogger: ::std::option::Option<
        unsafe extern "C" fn(
            logging_function: OrtLoggingFunction,
            logger_param: *mut ::std::os::raw::c_void,
            log_severity_level: OrtLoggingLevel,
            logid: *const ::std::os::raw::c_char,
            out: *mut *mut OrtEnv,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Enable Telemetry\n\n \\note Telemetry events are on by default since they are lightweight\n \\param[in] env\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub EnableTelemetryEvents:
        ::std::option::Option<unsafe extern "C" fn(env: *const OrtEnv) -> OrtStatusPtr>,
    #[doc = " \\brief Disable Telemetry\n\n \\see OrtApi::EnableTelemetryEvents\n \\param[in] env\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub DisableTelemetryEvents:
        ::std::option::Option<unsafe extern "C" fn(env: *const OrtEnv) -> OrtStatusPtr>,
    #[doc = " \\brief Create an OrtSession from a model file\n\n \\param[in] env\n \\param[in] model_path\n \\param[in] options\n \\param[out] out Returned newly created OrtSession. Must be freed with OrtApi::ReleaseSession\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateSession: ::std::option::Option<
        unsafe extern "C" fn(
            env: *const OrtEnv,
            model_path: *const wchar_t,
            options: *const OrtSessionOptions,
            out: *mut *mut OrtSession,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an OrtSession from memory\n\n \\param[in] env\n \\param[in] model_data\n \\param[in] model_data_length\n \\param[in] options\n \\param[out] out Returned newly created OrtSession. Must be freed with OrtApi::ReleaseSession\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateSessionFromArray: ::std::option::Option<
        unsafe extern "C" fn(
            env: *const OrtEnv,
            model_data: *const ::std::os::raw::c_void,
            model_data_length: usize,
            options: *const OrtSessionOptions,
            out: *mut *mut OrtSession,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Run the model in an ::OrtSession\n\n Will not return until the model run has completed. Multiple threads might be used to run the model based on\n the options in the ::OrtSession and settings used when creating the ::OrtEnv\n\n \\param[in] session\n \\param[in] run_options If nullptr, will use a default ::OrtRunOptions\n \\param[in] input_names Array of null terminated UTF8 encoded strings of the input names\n \\param[in] inputs Array of ::OrtValue%s of the input values\n \\param[in] input_len Number of elements in the input_names and inputs arrays\n \\param[in] output_names Array of null terminated UTF8 encoded strings of the output names\n \\param[in] output_names_len Number of elements in the output_names and outputs array\n \\param[out] outputs Array of ::OrtValue%s that the outputs are stored in. This can also be\n     an array of nullptr values, in this case ::OrtValue objects will be allocated and pointers\n     to them will be set into the `outputs` array.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub Run: ::std::option::Option<
        unsafe extern "C" fn(
            session: *mut OrtSession,
            run_options: *const OrtRunOptions,
            input_names: *const *const ::std::os::raw::c_char,
            inputs: *const *const OrtValue,
            input_len: usize,
            output_names: *const *const ::std::os::raw::c_char,
            output_names_len: usize,
            outputs: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtSessionOptions object\n\n To use additional providers, you must build ORT with the extra providers enabled. Then call one of these\n functions to enable them in the session:<br>\n   OrtSessionOptionsAppendExecutionProvider_CPU<br>\n   OrtSessionOptionsAppendExecutionProvider_CUDA<br>\n   OrtSessionOptionsAppendExecutionProvider_(remaining providers...)<br>\n The order they are called indicates the preference order as well. In other words call this method\n on your most preferred execution provider first followed by the less preferred ones.\n If none are called Ort will use its internal CPU execution provider.\n\n \\param[out] options The newly created OrtSessionOptions. Must be freed with OrtApi::ReleaseSessionOptions\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateSessionOptions: ::std::option::Option<
        unsafe extern "C" fn(options: *mut *mut OrtSessionOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set filepath to save optimized model after graph level transformations\n\n \\param[in] options\n \\param[in] optimized_model_filepath\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetOptimizedModelFilePath: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            optimized_model_filepath: *const wchar_t,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create a copy of an existing ::OrtSessionOptions\n\n \\param[in] in_options OrtSessionOptions to copy\n \\param[out] out_options Returned newly created ::OrtSessionOptions. Must be freed with OrtApi::ReleaseSessionOptions\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CloneSessionOptions: ::std::option::Option<
        unsafe extern "C" fn(
            in_options: *const OrtSessionOptions,
            out_options: *mut *mut OrtSessionOptions,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set execution mode\n\n Controls whether you want to execute operators in your graph sequentially or in parallel. Usually when the model\n  has many branches, setting this option to ExecutionMode.ORT_PARALLEL will give you better performance.\n  See [docs/ONNX_Runtime_Perf_Tuning.md] for more details.\n\n \\param[in] options\n \\param[in] execution_mode\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetSessionExecutionMode: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            execution_mode: ExecutionMode,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Enable profiling for a session\n\n \\param[in] options\n \\param[in] profile_file_prefix\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub EnableProfiling: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            profile_file_prefix: *const wchar_t,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Disable profiling for a session\n\n \\param[in] options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub DisableProfiling: ::std::option::Option<
        unsafe extern "C" fn(options: *mut OrtSessionOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Enable the memory pattern optimization\n\n The idea is if the input shapes are the same, we could trace the internal memory allocation\n and generate a memory pattern for future request. So next time we could just do one allocation\n with a big chunk for all the internal memory allocation.\n \\note Memory pattern optimization is only available when Sequential Execution mode is enabled (see OrtApi::SetSessionExecutionMode)\n\n \\see OrtApi::DisableMemPattern\n\n \\param[in] options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub EnableMemPattern: ::std::option::Option<
        unsafe extern "C" fn(options: *mut OrtSessionOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Disable the memory pattern optimization\n\n \\see OrtApi::EnableMemPattern\n\n \\param[in] options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub DisableMemPattern: ::std::option::Option<
        unsafe extern "C" fn(options: *mut OrtSessionOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Enable the memory arena on CPU\n\n Arena may pre-allocate memory for future usage.\n\n \\param[in] options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub EnableCpuMemArena: ::std::option::Option<
        unsafe extern "C" fn(options: *mut OrtSessionOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Disable the memory arena on CPU\n\n \\param[in] options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub DisableCpuMemArena: ::std::option::Option<
        unsafe extern "C" fn(options: *mut OrtSessionOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set session log id\n\n \\param[in] options\n \\param[in] logid The log identifier.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetSessionLogId: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            logid: *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set session log verbosity level\n\n Applies to session load, initialization, etc\n\n \\param[in] options\n \\param[in] session_log_verbosity_level \\snippet{doc} snippets.dox Log Verbosity Level\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetSessionLogVerbosityLevel: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            session_log_verbosity_level: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set session log severity level\n\n \\param[in] options\n \\param[in] session_log_severity_level The log severity level (refer to ::OrtLoggingLevel for possible values).\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetSessionLogSeverityLevel: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            session_log_severity_level: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set the optimization level to apply when loading a graph\n\n Please see https://onnxruntime.ai/docs/performance/model-optimizations/graph-optimizations.html for an in-depth explanation\n \\param[in,out] options The session options object\n \\param[in] graph_optimization_level The optimization level\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetSessionGraphOptimizationLevel: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            graph_optimization_level: GraphOptimizationLevel,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Sets the number of threads used to parallelize the execution within nodes\n\n When running a single node operation, ex. add, this sets the maximum number of threads to use.\n\n \\note If built with OpenMP, this has no effect on the number of threads used. In this case\n       use the OpenMP env variables to configure the number of intra op num threads.\n\n \\param[in] options\n \\param[in] intra_op_num_threads Number of threads to use<br>\n   A value of 0 will use the default number of threads<br>\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetIntraOpNumThreads: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            intra_op_num_threads: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Sets the number of threads used to parallelize the execution of the graph\n\n If nodes can be run in parallel, this sets the maximum number of threads to use to run them in parallel.\n\n \\note If sequential execution is enabled this value is ignored, it acts as if it was set to 1.\n\n \\param[in] options\n \\param[in] inter_op_num_threads Number of threads to use<br>\n   A value of 0 will use the default number of threads<br>\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetInterOpNumThreads: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            inter_op_num_threads: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create a custom op domain\n\n \\param[in] domain\n \\param[out] out Newly created domain. Must be freed with OrtApi::ReleaseCustomOpDomain\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateCustomOpDomain: ::std::option::Option<
        unsafe extern "C" fn(
            domain: *const ::std::os::raw::c_char,
            out: *mut *mut OrtCustomOpDomain,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Add a custom op to a custom op domain\n\n \\note The OrtCustomOp* pointer must remain valid until the ::OrtCustomOpDomain using it is released\n\n \\param[in] custom_op_domain\n \\param[in] op\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CustomOpDomain_Add: ::std::option::Option<
        unsafe extern "C" fn(
            custom_op_domain: *mut OrtCustomOpDomain,
            op: *const OrtCustomOp,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Add custom op domain to a session options\n\n \\note The OrtCustomOpDomain* must not be deleted until all sessions using it are released\n\n \\param[in] options\n \\param[in] custom_op_domain\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub AddCustomOpDomain: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            custom_op_domain: *mut OrtCustomOpDomain,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\deprecated Use OrtApi::RegisterCustomOpsLibrary_V2.\n\n Registers custom ops from a shared library.\n\n Loads a shared library (dll on windows, so on linux, etc) named 'library_path' and looks for this entry point:\n\t\tOrtStatus* RegisterCustomOps(OrtSessionOptions * options, const OrtApiBase* api);\n It then passes in the provided session options to this function along with the api base.\n The handle to the loaded library is returned in library_handle. It can be freed by the caller after all sessions using the passed in\n session options are destroyed, or if an error occurs and it is non null.\n\n \\param[in] options\n \\param[in] library_path\n \\param[out] library_handle OS specific handle to the loaded library (Use FreeLibrary on Windows, dlclose on Linux, etc.. to unload)\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub RegisterCustomOpsLibrary: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            library_path: *const ::std::os::raw::c_char,
            library_handle: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get input count for a session\n\n This number must also match the number of inputs passed to OrtApi::Run\n\n \\see OrtApi::SessionGetInputTypeInfo, OrtApi::SessionGetInputName, OrtApi::Session\n\n \\param[in] session\n \\param[out] out Number of inputs\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetInputCount: ::std::option::Option<
        unsafe extern "C" fn(session: *const OrtSession, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get output count for a session\n\n This number must also match the number of outputs returned by OrtApi::Run\n\n \\see OrtApi::SessionGetOutputTypeInfo, OrtApi::SessionGetOutputName, OrtApi::Session\n\n \\param[in] session\n \\param[out] out Number of outputs\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetOutputCount: ::std::option::Option<
        unsafe extern "C" fn(session: *const OrtSession, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get overridable initializer count\n\n \\see OrtApi::SessionGetOverridableInitializerTypeInfo, OrtApi::SessionGetOverridableInitializerName\n\n \\param[in] session\n \\param[in] out\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetOverridableInitializerCount: ::std::option::Option<
        unsafe extern "C" fn(session: *const OrtSession, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get input type information\n\n \\param[in] session\n \\param[in] index Must be between 0 (inclusive) and what OrtApi::SessionGetInputCount returns (exclusive)\n \\param[out] type_info Must be freed with OrtApi::ReleaseTypeInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetInputTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            session: *const OrtSession,
            index: usize,
            type_info: *mut *mut OrtTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get output type information\n\n \\param[in] session\n \\param[in] index Must be between 0 (inclusive) and what OrtApi::SessionGetOutputCount returns (exclusive)\n \\param[out] type_info Must be freed with OrtApi::ReleaseTypeInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetOutputTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            session: *const OrtSession,
            index: usize,
            type_info: *mut *mut OrtTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get overridable initializer type information\n\n \\param[in] session\n \\param[in] index Must be between 0 (inclusive) and what OrtApi::SessionGetOverridableInitializerCount returns (exclusive)\n \\param[out] type_info Must be freed with OrtApi::ReleaseTypeInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetOverridableInitializerTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            session: *const OrtSession,
            index: usize,
            type_info: *mut *mut OrtTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get input name\n\n \\param[in] session\n \\param[in] index Must be between 0 (inclusive) and what OrtApi::SessionGetInputCount returns (exclusive)\n \\param[in] allocator\n \\param[out] value Set to a null terminated UTF-8 encoded string allocated using `allocator`. Must be freed using `allocator`.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetInputName: ::std::option::Option<
        unsafe extern "C" fn(
            session: *const OrtSession,
            index: usize,
            allocator: *mut OrtAllocator,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get output name\n\n \\param[in] session\n \\param[in] index Must be between 0 (inclusive) and what OrtApi::SessionGetOutputCount returns (exclusive)\n \\param[in] allocator\n \\param[out] value Set to a null terminated UTF-8 encoded string allocated using `allocator`. Must be freed using `allocator`.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetOutputName: ::std::option::Option<
        unsafe extern "C" fn(
            session: *const OrtSession,
            index: usize,
            allocator: *mut OrtAllocator,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get overridable initializer name\n\n \\param[in] session\n \\param[in] index Must be between 0 (inclusive) and what OrtApi::SessionGetOverridableInitializerCount returns (exclusive)\n \\param[in] allocator\n \\param[out] value Set to a null terminated UTF-8 encoded string allocated using `allocator`. Must be freed using `allocator`.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetOverridableInitializerName: ::std::option::Option<
        unsafe extern "C" fn(
            session: *const OrtSession,
            index: usize,
            allocator: *mut OrtAllocator,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an OrtRunOptions\n\n \\param[out] out Returned newly created ::OrtRunOptions. Must be freed with OrtApi::ReleaseRunOptions\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateRunOptions:
        ::std::option::Option<unsafe extern "C" fn(out: *mut *mut OrtRunOptions) -> OrtStatusPtr>,
    #[doc = " \\brief Set per-run log verbosity level\n\n \\see OrtApi::RunOptionsGetRunLogVerbosityLevel\n\n \\param[in] options\n \\param[in] log_verbosity_level \\snippet{doc} snippets.dox Log Verbosity Level\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub RunOptionsSetRunLogVerbosityLevel: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtRunOptions,
            log_verbosity_level: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set per-run log severity level\n\n \\see OrtApi::RunOptionsGetRunLogSeverityLevel\n\n \\param[in] options\n \\param[in] log_severity_level The log severity level (refer to ::OrtLoggingLevel for possible values)."]
    pub RunOptionsSetRunLogSeverityLevel: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtRunOptions,
            log_severity_level: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set per-run tag\n\n This is used in a per-run log identifier.\n\n \\see OrtApi::RunOptionsGetRunTag\n\n \\param[in] options\n \\param[in] run_tag The run tag."]
    pub RunOptionsSetRunTag: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtRunOptions,
            run_tag: *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get per-run log verbosity level\n\n \\see OrtApi::RunOptionsSetRunLogVerbosityLevel\n\n \\param[in] options\n \\param[out] log_verbosity_level \\snippet{doc} snippets.dox Log Verbosity Level\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub RunOptionsGetRunLogVerbosityLevel: ::std::option::Option<
        unsafe extern "C" fn(
            options: *const OrtRunOptions,
            log_verbosity_level: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get per-run log severity level\n\n \\see OrtApi::RunOptionsSetRunLogSeverityLevel\n\n \\param[in] options\n \\param[out] log_severity_level The log severity level (refer to ::OrtLoggingLevel for possible values)."]
    pub RunOptionsGetRunLogSeverityLevel: ::std::option::Option<
        unsafe extern "C" fn(
            options: *const OrtRunOptions,
            log_severity_level: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get per-run tag\n\n This is used in a per-run log identifier.\n\n \\see OrtApi::RunOptionsSetRunTag\n\n \\param[in] options\n \\param[out] run_tag The run tag.\n                     Do not free this value, it is owned by `options`. It will be invalidated if the run tag\n                     changes (i.e., with OrtApi::RunOptionsSetRunTag) or `options` is freed."]
    pub RunOptionsGetRunTag: ::std::option::Option<
        unsafe extern "C" fn(
            options: *const OrtRunOptions,
            run_tag: *mut *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set terminate flag\n\n If a currently executing session needs to be force terminated, this can be called from another thread to force it to fail with an error.\n\n \\param[in] options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub RunOptionsSetTerminate:
        ::std::option::Option<unsafe extern "C" fn(options: *mut OrtRunOptions) -> OrtStatusPtr>,
    #[doc = " \\brief Clears the terminate flag\n\n Used so the OrtRunOptions instance can be used in a new OrtApi::Run call without it instantly terminating\n\n \\param[in] options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub RunOptionsUnsetTerminate:
        ::std::option::Option<unsafe extern "C" fn(options: *mut OrtRunOptions) -> OrtStatusPtr>,
    #[doc = " \\brief Create a tensor\n\n Create a tensor using a supplied ::OrtAllocator\n\n \\param[in] allocator\n \\param[in] shape Pointer to the tensor shape dimensions.\n \\param[in] shape_len The number of tensor shape dimensions.\n \\param[in] type\n \\param[out] out Returns newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateTensorAsOrtValue: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut OrtAllocator,
            shape: *const i64,
            shape_len: usize,
            type_: ONNXTensorElementDataType,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create a tensor backed by a user supplied buffer\n\n Create a tensor with user's buffer. You can fill the buffer either before calling this function or after.\n p_data is owned by caller. ReleaseValue won't release p_data.\n\n \\param[in] info Memory description of where the p_data buffer resides (CPU vs GPU etc).\n \\param[in] p_data Pointer to the data buffer.\n \\param[in] p_data_len The number of bytes in the data buffer.\n \\param[in] shape Pointer to the tensor shape dimensions.\n \\param[in] shape_len The number of tensor shape dimensions.\n \\param[in] type The data type.\n \\param[out] out Returns newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateTensorWithDataAsOrtValue: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtMemoryInfo,
            p_data: *mut ::std::os::raw::c_void,
            p_data_len: usize,
            shape: *const i64,
            shape_len: usize,
            type_: ONNXTensorElementDataType,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Return if an ::OrtValue is a tensor type\n\n \\param[in] value A tensor type (string tensors are not supported)\n \\param[out] out Set to 1 iff ::OrtValue is a tensor, 0 otherwise\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub IsTensor: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const OrtValue,
            out: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get a pointer to the raw data inside a tensor\n\n Used to read/write/modify the internal tensor data directly.\n \\note The returned pointer is valid until the \\p value is destroyed.\n\n \\param[in] value A tensor type (string tensors are not supported)\n \\param[out] out Filled in with a pointer to the internal storage\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetTensorMutableData: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut OrtValue,
            out: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set all strings at once in a string tensor\n\n \\param[in,out] value A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING\n \\param[in] s An array of strings. Each string in this array must be null terminated.\n \\param[in] s_len Count of strings in s (Must match the size of \\p value's tensor shape)\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub FillStringTensor: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut OrtValue,
            s: *const *const ::std::os::raw::c_char,
            s_len: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get total byte length for all strings in a string tensor\n\n Typically used with OrtApi::GetStringTensorContent\n\n \\param[in] value A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING\n \\param[out] len Total byte length of all strings (does not include trailing nulls)\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetStringTensorDataLength: ::std::option::Option<
        unsafe extern "C" fn(value: *const OrtValue, len: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get all strings from a string tensor\n\n An example of the results:<br>\n Given \\p value is a string tensor with the strings { \"This\" \"is\" \"a\" \"test\" }<br>\n \\p s must have a size of 11 bytes<br>\n \\p offsets must have 4 elements<br>\n After the call, these values will be filled in:<br>\n \\p s will contain \"Thisisatest\"<br>\n \\p offsets will contain { 0, 4, 6, 7 }<br>\n The length of the last string is just s_len - offsets[last]\n\n \\param[in] value A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING\n \\param[in] s Buffer to sequentially write all tensor strings to. Each string is NOT null-terminated.\n \\param[in] s_len Number of bytes of buffer pointed to by \\p s (Get it from OrtApi::GetStringTensorDataLength)\n \\param[out] offsets Array of start offsets into the strings written to \\p s\n \\param[in] offsets_len Number of elements in offsets\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetStringTensorContent: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const OrtValue,
            s: *mut ::std::os::raw::c_void,
            s_len: usize,
            offsets: *mut usize,
            offsets_len: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get ::OrtTensorTypeAndShapeInfo from an ::OrtTypeInfo\n\n \\param[in] type_info\n \\param[out] out Do not free this value, it will be valid until type_info is freed.\n             If type_info does not represent tensor, this value will be set to nullptr.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CastTypeInfoToTensorInfo: ::std::option::Option<
        unsafe extern "C" fn(
            type_info: *const OrtTypeInfo,
            out: *mut *const OrtTensorTypeAndShapeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get ::ONNXType from ::OrtTypeInfo\n\n \\param[in] type_info\n \\param[out] out\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetOnnxTypeFromTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(type_info: *const OrtTypeInfo, out: *mut ONNXType) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtTensorTypeAndShapeInfo object\n\n \\param[out] out Returns newly created ::OrtTensorTypeAndShapeInfo. Must be freed with OrtApi::ReleaseTensorTypeAndShapeInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateTensorTypeAndShapeInfo: ::std::option::Option<
        unsafe extern "C" fn(out: *mut *mut OrtTensorTypeAndShapeInfo) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set element type in ::OrtTensorTypeAndShapeInfo\n\n \\param[in] info\n \\param[in] type\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetTensorElementType: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut OrtTensorTypeAndShapeInfo,
            type_: ONNXTensorElementDataType,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set shape information in ::OrtTensorTypeAndShapeInfo\n\n \\param[in] info\n \\param[in] dim_values Array with `dim_count` elements. Can contain negative values.\n \\param[in] dim_count Number of elements in `dim_values`\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetDimensions: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut OrtTensorTypeAndShapeInfo,
            dim_values: *const i64,
            dim_count: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get element type in ::OrtTensorTypeAndShapeInfo\n\n \\see OrtApi::SetTensorElementType\n\n \\param[in] info\n \\param[out] out\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetTensorElementType: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtTensorTypeAndShapeInfo,
            out: *mut ONNXTensorElementDataType,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get dimension count in ::OrtTensorTypeAndShapeInfo\n\n \\see OrtApi::GetDimensions\n\n \\param[in] info\n \\param[out] out\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetDimensionsCount: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtTensorTypeAndShapeInfo,
            out: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get dimensions in ::OrtTensorTypeAndShapeInfo\n\n \\param[in] info\n \\param[out] dim_values Array with `dim_values_length` elements. On return, filled with the dimensions stored in the ::OrtTensorTypeAndShapeInfo\n \\param[in] dim_values_length Number of elements in `dim_values`. Use OrtApi::GetDimensionsCount to get this value\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetDimensions: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtTensorTypeAndShapeInfo,
            dim_values: *mut i64,
            dim_values_length: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get symbolic dimension names in ::OrtTensorTypeAndShapeInfo\n\n \\param[in] info\n \\param[in] dim_params Array with `dim_params_length` elements. On return filled with pointers to null terminated strings of the dimension names\n \\param[in] dim_params_length Number of elements in `dim_params`. Use OrtApi::GetDimensionsCount to get this value\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetSymbolicDimensions: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtTensorTypeAndShapeInfo,
            dim_params: *mut *const ::std::os::raw::c_char,
            dim_params_length: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get total number of elements in a tensor shape from an ::OrtTensorTypeAndShapeInfo\n\n Return the number of elements specified by the tensor shape (all dimensions multiplied by each other).\n For 0 dimensions, 1 is returned. If any dimension is less than 0, the result is always -1.\n\n Examples:<br>\n [] = 1<br>\n [1,3,4] = 12<br>\n [2,0,4] = 0<br>\n [-1,3,4] = -1<br>\n\n \\param[in] info\n \\param[out] out Number of elements\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetTensorShapeElementCount: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtTensorTypeAndShapeInfo,
            out: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get type and shape information from a tensor ::OrtValue\n\n \\param[in] value Must be a tensor (not a map/sequence/etc) or will return failure\n \\param[out] out Newly created ::OrtTensorTypeAndShapeInfo. Must be freed with OrtApi::ReleaseTensorTypeAndShapeInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetTensorTypeAndShape: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const OrtValue,
            out: *mut *mut OrtTensorTypeAndShapeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get type information of an OrtValue\n\n \\param[in] value\n \\param[out] out Newly created ::OrtTypeInfo. Must be freed with OrtApi::ReleaseTypeInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(value: *const OrtValue, out: *mut *mut OrtTypeInfo) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get ONNXType of an ::OrtValue\n\n \\param[in] value\n \\param[out] out\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetValueType: ::std::option::Option<
        unsafe extern "C" fn(value: *const OrtValue, out: *mut ONNXType) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtMemoryInfo\n\n \\param[in] name\n \\param[in] type\n \\param[in] id\n \\param[in] mem_type\n \\param[out] out Newly created ::OrtMemoryInfo. Must be freed with OrtAPi::ReleaseMemoryInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateMemoryInfo: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            type_: OrtAllocatorType,
            id: ::std::os::raw::c_int,
            mem_type: OrtMemType,
            out: *mut *mut OrtMemoryInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtMemoryInfo for CPU memory\n\n Special case version of OrtApi::CreateMemoryInfo for CPU based memory. Same as using OrtApi::CreateMemoryInfo with name = \"Cpu\" and id = 0.\n\n \\param[in] type\n \\param[in] mem_type\n \\param[out] out\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateCpuMemoryInfo: ::std::option::Option<
        unsafe extern "C" fn(
            type_: OrtAllocatorType,
            mem_type: OrtMemType,
            out: *mut *mut OrtMemoryInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Compare ::OrtMemoryInfo objects for equality\n\n Compares all settings of each ::OrtMemoryInfo for equality\n\n \\param[in] info1\n \\param[in] info2\n \\param[out] out Set to 0 if equal, -1 if not equal\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CompareMemoryInfo: ::std::option::Option<
        unsafe extern "C" fn(
            info1: *const OrtMemoryInfo,
            info2: *const OrtMemoryInfo,
            out: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get name from ::OrtMemoryInfo\n\n \\param[in] ptr\n \\param[out] out Writes null terminated string to this pointer. Do NOT free the returned pointer. It is valid for the lifetime of the ::OrtMemoryInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub MemoryInfoGetName: ::std::option::Option<
        unsafe extern "C" fn(
            ptr: *const OrtMemoryInfo,
            out: *mut *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the id from ::OrtMemoryInfo"]
    pub MemoryInfoGetId: ::std::option::Option<
        unsafe extern "C" fn(
            ptr: *const OrtMemoryInfo,
            out: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the ::OrtMemType from ::OrtMemoryInfo"]
    pub MemoryInfoGetMemType: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const OrtMemoryInfo, out: *mut OrtMemType) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the ::OrtAllocatorType from ::OrtMemoryInfo"]
    pub MemoryInfoGetType: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const OrtMemoryInfo, out: *mut OrtAllocatorType) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Calls OrtAllocator::Alloc function"]
    pub AllocatorAlloc: ::std::option::Option<
        unsafe extern "C" fn(
            ort_allocator: *mut OrtAllocator,
            size: usize,
            out: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Calls OrtAllocator::Free function"]
    pub AllocatorFree: ::std::option::Option<
        unsafe extern "C" fn(
            ort_allocator: *mut OrtAllocator,
            p: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Calls OrtAllocator::Info function"]
    pub AllocatorGetInfo: ::std::option::Option<
        unsafe extern "C" fn(
            ort_allocator: *const OrtAllocator,
            out: *mut *const OrtMemoryInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the default allocator\n\n The default allocator is a CPU based, non-arena. Always returns the same pointer to the same default allocator.\n\n \\param[out] out Returned value should NOT be freed\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetAllocatorWithDefaultOptions:
        ::std::option::Option<unsafe extern "C" fn(out: *mut *mut OrtAllocator) -> OrtStatusPtr>,
    #[doc = " \\brief Override session symbolic dimensions\n\n Override symbolic dimensions (by specific denotation strings) with actual values if known at session initialization time to enable\n optimizations that can take advantage of fixed values (such as memory planning, etc)\n\n \\param[in] options\n \\param[in] dim_denotation\n \\param[in] dim_value\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub AddFreeDimensionOverride: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            dim_denotation: *const ::std::os::raw::c_char,
            dim_value: i64,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get non tensor data from an ::OrtValue\n\n If `value` is of type ONNX_TYPE_MAP, you need to retrieve the keys and values\n separately. Use index=0 to retrieve keys and index=1 to retrieve values.\n If `value` is of type ONNX_TYPE_SEQUENCE, use index to retrieve the index'th element\n of the sequence.\n\n \\param[in] value\n \\param[in] index See above for usage based on `value` type\n \\param[in] allocator Allocator used to allocate ::OrtValue\n \\param[out] out Created ::OrtValue that holds the element requested. Must be freed with OrtApi::ReleaseValue\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetValue: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const OrtValue,
            index: ::std::os::raw::c_int,
            allocator: *mut OrtAllocator,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get non tensor value count from an ::OrtValue\n\n If `value` is of type ONNX_TYPE_MAP 2 will always be returned. For ONNX_TYPE_SEQUENCE\n the number of elements in the sequence will be returned\n\n \\param[in] value\n \\param[out] out\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetValueCount: ::std::option::Option<
        unsafe extern "C" fn(value: *const OrtValue, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create a map or sequence ::OrtValue\n\n To construct a map (ONNX_TYPE_MAP), use num_values = 2 and `in` should be an array of 2 ::OrtValue%s\n representing keys and values.<br>\n\n To construct a sequence (ONNX_TYPE_SEQUENCE), use num_values = N where N is the number of the elements in the\n sequence. 'in' should be an array of N ::OrtValue%s.\n\n \\param[in] in See above for details\n \\param[in] num_values\n \\param[in] value_type Must be either ONNX_TYPE_MAP or ONNX_TYPE_SEQUENCE\n \\param[out] out Newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateValue: ::std::option::Option<
        unsafe extern "C" fn(
            in_: *const *const OrtValue,
            num_values: usize,
            value_type: ONNXType,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an opaque (custom user defined type) ::OrtValue\n\n Constructs an ::OrtValue that contains a value of non-standard type created for\n experiments or while awaiting standardization. ::OrtValue in this case would contain\n an internal representation of the Opaque type. Opaque types are distinguished from\n each other by two strings 1) domain and 2) type name. The combination of the two\n must be unique, so the type representation is properly identified internally. The combination\n must be properly registered from within ORT at both compile/run time or by another API.\n\n To construct the ::OrtValue pass domain and type names, also a pointer to a data container\n the type of which must be known to both ORT and the client program. That data container may or may\n not match the internal representation of the Opaque type. The sizeof(data_container) is passed for\n verification purposes.\n\n \\param[in] domain_name Null terminated string of the domain name\n \\param[in] type_name Null terminated string of the type name\n \\param[in] data_container User pointer Data to populate ::OrtValue\n \\param[in] data_container_size Size in bytes of what `data_container` points to\n \\param[out] out Newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateOpaqueValue: ::std::option::Option<
        unsafe extern "C" fn(
            domain_name: *const ::std::os::raw::c_char,
            type_name: *const ::std::os::raw::c_char,
            data_container: *const ::std::os::raw::c_void,
            data_container_size: usize,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get internal data from an opaque (custom user defined type) ::OrtValue\n\n Copies internal data from an opaque value into a user provided buffer\n\n \\see OrtApi::CreateOpaqueValue\n\n \\param[in] domain_name Null terminated string of the domain name\n \\param[in] type_name Null terminated string of the type name\n \\param[in] in The opaque ::OrtValue\n \\param[out] data_container Buffer to copy data into\n \\param[out] data_container_size Size in bytes of the buffer pointed to by data_container. Must match the size of the internal buffer.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetOpaqueValue: ::std::option::Option<
        unsafe extern "C" fn(
            domain_name: *const ::std::os::raw::c_char,
            type_name: *const ::std::os::raw::c_char,
            in_: *const OrtValue,
            data_container: *mut ::std::os::raw::c_void,
            data_container_size: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get a float stored as an attribute in the graph node\n\n \\param[in] info ::OrtKernelInfo instance\n \\param[in] name Null terminated string of the name of the attribute\n \\param[out] out Pointer to memory where the attribute will be stored\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub KernelInfoGetAttribute_float: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            name: *const ::std::os::raw::c_char,
            out: *mut f32,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Fetch a 64-bit int stored as an attribute in the graph node\n\n \\param[in] info ::OrtKernelInfo instance\n \\param[in] name Null terminated string of the name of the attribute\n \\param[out] out Pointer to memory where the attribute will be stored\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub KernelInfoGetAttribute_int64: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            name: *const ::std::os::raw::c_char,
            out: *mut i64,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Fetch a string stored as an attribute in the graph node\n\n If `out` is nullptr, the value of `size` is set to the true size of the string\n attribute, and a success status is returned.\n\n If the `size` parameter is greater than or equal to the actual string attribute's size,\n the value of `size` is set to the true size of the string attribute, the provided memory\n is filled with the attribute's contents, and a success status is returned.\n\n If the `size` parameter is less than the actual string attribute's size and `out`\n is not nullptr, the value of `size` is set to the true size of the string attribute\n and a failure status is returned.)\n\n \\param[in] info ::OrtKernelInfo instance\n \\param[in] name Null terminated string of the name of the attribute\n \\param[out] out Pointer to memory where the attribute will be stored\n \\param[in,out] size See above comments for details\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub KernelInfoGetAttribute_string: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            name: *const ::std::os::raw::c_char,
            out: *mut ::std::os::raw::c_char,
            size: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Used for custom operators, get the input count of a kernel\n\n \\see ::OrtCustomOp"]
    pub KernelContext_GetInputCount: ::std::option::Option<
        unsafe extern "C" fn(context: *const OrtKernelContext, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Used for custom operators, get the output count of a kernel\n\n \\see ::OrtCustomOp"]
    pub KernelContext_GetOutputCount: ::std::option::Option<
        unsafe extern "C" fn(context: *const OrtKernelContext, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Used for custom operators, get an input of a kernel\n\n \\see ::OrtCustomOp"]
    pub KernelContext_GetInput: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtKernelContext,
            index: usize,
            out: *mut *const OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Used for custom operators, get an output of a kernel\n\n \\see ::OrtCustomOp"]
    pub KernelContext_GetOutput: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut OrtKernelContext,
            index: usize,
            dim_values: *const i64,
            dim_count: usize,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " @}\n \\name OrtEnv\n @{"]
    pub ReleaseEnv: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtEnv)>,
    #[doc = " @}\n \\name OrtStatus\n @{"]
    pub ReleaseStatus: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtStatus)>,
    #[doc = " @}\n \\name OrtMemoryInfo\n @{"]
    pub ReleaseMemoryInfo: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtMemoryInfo)>,
    #[doc = " @}\n \\name OrtSession\n @{"]
    pub ReleaseSession: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtSession)>,
    #[doc = " @}\n \\name OrtValue\n @{"]
    pub ReleaseValue: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtValue)>,
    #[doc = " @}\n \\name OrtRunOptions\n @{"]
    pub ReleaseRunOptions: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtRunOptions)>,
    #[doc = " @}\n \\name OrtTypeInfo\n @{"]
    pub ReleaseTypeInfo: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtTypeInfo)>,
    #[doc = " @}\n \\name OrtTensorTypeAndShapeInfo\n @{"]
    pub ReleaseTensorTypeAndShapeInfo:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtTensorTypeAndShapeInfo)>,
    #[doc = " @}\n \\name OrtSessionOptions\n @{"]
    pub ReleaseSessionOptions:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtSessionOptions)>,
    #[doc = " @}\n \\name OrtCustomOpDomain\n @{"]
    pub ReleaseCustomOpDomain:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtCustomOpDomain)>,
    #[doc = " \\brief Get denotation from type information\n\n Augments ::OrtTypeInfo to return denotations on the type.\n\n This is used by WinML to determine if an input/output is intended to be an Image or a Tensor.\n\n \\param[in] type_info\n \\param[out] denotation Pointer to the null terminated denotation string is written to this pointer. This pointer is valid until the object is destroyed or the name is changed, do not free.\n \\param[out] len Length in bytes of the string returned in `denotation`\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetDenotationFromTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            type_info: *const OrtTypeInfo,
            denotation: *mut *const ::std::os::raw::c_char,
            len: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get detailed map information from an ::OrtTypeInfo\n\n This augments ::OrtTypeInfo to return an ::OrtMapTypeInfo when the type is a map.\n The OrtMapTypeInfo has additional information about the map's key type and value type.\n\n This is used by WinML to support model reflection APIs.\n\n \\param[out] type_info\n \\param[out] out A pointer to the ::OrtMapTypeInfo. Do not free this value. If type_info\n             does not contain a map, this value will be set to nullptr.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CastTypeInfoToMapTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            type_info: *const OrtTypeInfo,
            out: *mut *const OrtMapTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Cast ::OrtTypeInfo to an ::OrtSequenceTypeInfo\n\n This api augments ::OrtTypeInfo to return an ::OrtSequenceTypeInfo when the type is a sequence.\n The ::OrtSequenceTypeInfo has additional information about the sequence's element type.\n\n This is used by WinML to support model reflection APIs.\n\n \\param[in] type_info\n \\param[out] out A pointer to the OrtSequenceTypeInfo. Do not free this value. If type_info\n             doesn not contain a sequence, this value will be set to nullptr.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CastTypeInfoToSequenceTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            type_info: *const OrtTypeInfo,
            out: *mut *const OrtSequenceTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get key type from an ::OrtMapTypeInfo\n\n Key types are restricted to being scalar types.\n\n This is used by WinML to support model reflection APIs.\n\n \\param[in] map_type_info\n \\param[out] out\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetMapKeyType: ::std::option::Option<
        unsafe extern "C" fn(
            map_type_info: *const OrtMapTypeInfo,
            out: *mut ONNXTensorElementDataType,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the value type from an ::OrtMapTypeInfo\n\n \\param[in] map_type_info\n \\param[out] type_info\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetMapValueType: ::std::option::Option<
        unsafe extern "C" fn(
            map_type_info: *const OrtMapTypeInfo,
            type_info: *mut *mut OrtTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get element type from an ::OrtSequenceTypeInfo\n\n This is used by WinML to support model reflection APIs.\n\n \\param[in] sequence_type_info\n \\param[out] type_info\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetSequenceElementType: ::std::option::Option<
        unsafe extern "C" fn(
            sequence_type_info: *const OrtSequenceTypeInfo,
            type_info: *mut *mut OrtTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " @}\n \\name OrtMapTypeInfo\n @{"]
    pub ReleaseMapTypeInfo: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtMapTypeInfo)>,
    #[doc = " @}\n \\name OrtSequenceTypeInfo\n @{"]
    pub ReleaseSequenceTypeInfo:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtSequenceTypeInfo)>,
    #[doc = " \\brief End profiling and return filename of the profile data\n\n Profiling is turned on through OrtApi::EnableProfiling\n\n \\param[in] session\n \\param[in] allocator\n \\param[out] out Null terminated string of the filename, allocated using `allocator`. Must be freed using `allocator`\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionEndProfiling: ::std::option::Option<
        unsafe extern "C" fn(
            session: *mut OrtSession,
            allocator: *mut OrtAllocator,
            out: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get ::OrtModelMetadata from an ::OrtSession\n\n \\param[in] session\n \\param[out] out Newly created ::OrtModelMetadata. Must be freed using OrtApi::ReleaseModelMetadata\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetModelMetadata: ::std::option::Option<
        unsafe extern "C" fn(
            session: *const OrtSession,
            out: *mut *mut OrtModelMetadata,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get `producer name` from an ::OrtModelMetadata\n\n \\param[in] model_metadata\n \\param[in] allocator\n \\param[out] value Set to a null terminated string allocated using `allocator`. Must be freed using `allocator`\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ModelMetadataGetProducerName: ::std::option::Option<
        unsafe extern "C" fn(
            model_metadata: *const OrtModelMetadata,
            allocator: *mut OrtAllocator,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get `graph name` from an ::OrtModelMetadata\n\n \\param[in] model_metadata\n \\param[in] allocator\n \\param[out] value Set to a null terminated string allocated using `allocator`. Must be freed using `allocator`\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ModelMetadataGetGraphName: ::std::option::Option<
        unsafe extern "C" fn(
            model_metadata: *const OrtModelMetadata,
            allocator: *mut OrtAllocator,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get `domain` from an ::OrtModelMetadata\n\n \\param[in] model_metadata\n \\param[in] allocator\n \\param[out] value Set to a null terminated string allocated using `allocator`. Must be freed using `allocator`\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ModelMetadataGetDomain: ::std::option::Option<
        unsafe extern "C" fn(
            model_metadata: *const OrtModelMetadata,
            allocator: *mut OrtAllocator,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get `description` from an ::OrtModelMetadata\n\n \\param[in] model_metadata\n \\param[in] allocator\n \\param[out] value Set to a null terminated string allocated using `allocator`. Must be freed using `allocator`\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ModelMetadataGetDescription: ::std::option::Option<
        unsafe extern "C" fn(
            model_metadata: *const OrtModelMetadata,
            allocator: *mut OrtAllocator,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Return data for a key in the custom metadata map in an ::OrtModelMetadata\n\n \\param[in] model_metadata\n \\param[in] allocator\n \\param[in] key Null terminated string\n \\param[out] value Set to a null terminated string allocated using `allocator`. Must be freed using `allocator`\n `value` will be set to nullptr if the given key is not found in the custom metadata map.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ModelMetadataLookupCustomMetadataMap: ::std::option::Option<
        unsafe extern "C" fn(
            model_metadata: *const OrtModelMetadata,
            allocator: *mut OrtAllocator,
            key: *const ::std::os::raw::c_char,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get version number from an ::OrtModelMetadata\n\n \\param[in] model_metadata\n \\param[out] value Set to the version number\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ModelMetadataGetVersion: ::std::option::Option<
        unsafe extern "C" fn(
            model_metadata: *const OrtModelMetadata,
            value: *mut i64,
        ) -> OrtStatusPtr,
    >,
    pub ReleaseModelMetadata:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtModelMetadata)>,
    #[doc = " \\brief Create an OrtEnv\n\n Create an environment with global threadpools that will be shared across sessions.\n Use this in conjunction with OrtApi::DisablePerSessionThreads or else the session will use\n its own thread pools.\n\n \\param[in] log_severity_level The log severity level.\n \\param[in] logid The log identifier.\n \\param[in] tp_options\n \\param[out] out Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateEnvWithGlobalThreadPools: ::std::option::Option<
        unsafe extern "C" fn(
            log_severity_level: OrtLoggingLevel,
            logid: *const ::std::os::raw::c_char,
            tp_options: *const OrtThreadingOptions,
            out: *mut *mut OrtEnv,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Use global thread pool on a session\n\n Disable using per session thread pool and use the shared global threadpool.\n This should be used in conjunction with OrtApi::CreateEnvWithGlobalThreadPools.\n\n \\param[in] options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub DisablePerSessionThreads: ::std::option::Option<
        unsafe extern "C" fn(options: *mut OrtSessionOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtThreadingOptions\n\n \\param[out] out Newly created ::OrtThreadingOptions. Must be freed with OrtApi::ReleaseThreadingOptions\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateThreadingOptions: ::std::option::Option<
        unsafe extern "C" fn(out: *mut *mut OrtThreadingOptions) -> OrtStatusPtr,
    >,
    pub ReleaseThreadingOptions:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtThreadingOptions)>,
    #[doc = " \\param[in] model_metadata\n \\param[in] allocator\n \\param[out] keys Array of null terminated strings (array count = num_keys) allocated using `allocator`.\n  The strings and the pointer array must be freed using `allocator`\n  `keys` will be set to nullptr if the custom metadata map is empty.\n \\param[out] num_keys Set to the number of elements in the `keys` array\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ModelMetadataGetCustomMetadataMapKeys: ::std::option::Option<
        unsafe extern "C" fn(
            model_metadata: *const OrtModelMetadata,
            allocator: *mut OrtAllocator,
            keys: *mut *mut *mut ::std::os::raw::c_char,
            num_keys: *mut i64,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Override symbolic dimensions (by specific name strings) with actual values\n if known at session initialization time to enable optimizations that can\n take advantage of fixed values (such as memory planning, etc)\n"]
    pub AddFreeDimensionOverrideByName: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            dim_name: *const ::std::os::raw::c_char,
            dim_value: i64,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the names of all available providers\n\n \\note The providers in the list are not guaranteed to be usable. They may fail to load due to missing system dependencies.\n    For example, if the CUDA/cuDNN libraries are not installed, the CUDA provider will report an error when it is added to the session options.\n\n \\param[out] out_ptr Set to a pointer to an array of null terminated strings of the available providers. The entries and the\n    array itself must be freed using OrtApi::ReleaseAvailableProviders\n \\param[out] provider_length Set to the number of entries in the `out_ptr` array\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetAvailableProviders: ::std::option::Option<
        unsafe extern "C" fn(
            out_ptr: *mut *mut *mut ::std::os::raw::c_char,
            provider_length: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release data from OrtApi::GetAvailableProviders. This API will never fail\n so you can rely on it in a noexcept code.\n\n \\param[in] ptr The `out_ptr` result from OrtApi::GetAvailableProviders.\n \\param[in] providers_length The `provider_length` result from OrtApi::GetAvailableProviders\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ReleaseAvailableProviders: ::std::option::Option<
        unsafe extern "C" fn(
            ptr: *mut *mut ::std::os::raw::c_char,
            providers_length: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the length of a single string in a string tensor\n\n \\param[in] value A string tensor\n \\param[in] index Index of the string in the tensor\n \\param[out] out Set to number of bytes of the string element\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetStringTensorElementLength: ::std::option::Option<
        unsafe extern "C" fn(value: *const OrtValue, index: usize, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get a single string from a string tensor\n\n \\param[in] value A string tensor\n \\param[in] s_len Number of bytes in the `s` buffer. Must match the value returned by OrtApi::GetStringTensorElementLength.\n \\param[in] index Index of the string in the tensor\n \\param[out] s The string element contents in UTF-8 encoding. The string is NOT null-terminated.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetStringTensorElement: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const OrtValue,
            s_len: usize,
            index: usize,
            s: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set a single string in a string tensor\n\n \\param[in] value A string tensor\n \\param[in] s A null terminated UTF-8 encoded string\n \\param[in] index Index of the string in the tensor to set\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub FillStringTensorElement: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut OrtValue,
            s: *const ::std::os::raw::c_char,
            index: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set a session configuration entry as a pair of strings\n\n If a configuration with same key exists, this will overwrite the configuration with the given config_value.\n\n The config_key and the format of config_value are defined in onnxruntime_session_options_config_keys.h\n\n \\param[in] options\n \\param[in] config_key A null terminated string representation of the config key\n \\param[in] config_value A null terminated string representation of the config value\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub AddSessionConfigEntry: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            config_key: *const ::std::os::raw::c_char,
            config_value: *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an allocator for an ::OrtSession following an ::OrtMemoryInfo\n\n \\param[in] session\n \\param[in] mem_info valid ::OrtMemoryInfo instance\n \\param[out] out Newly created ::OrtAllocator. Must be freed with OrtApi::ReleaseAllocator\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateAllocator: ::std::option::Option<
        unsafe extern "C" fn(
            session: *const OrtSession,
            mem_info: *const OrtMemoryInfo,
            out: *mut *mut OrtAllocator,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release an ::OrtAllocator obtained from OrtApi::CreateAllocator"]
    pub ReleaseAllocator: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtAllocator)>,
    #[doc = " \\brief Run a model using Io Bindings for the inputs & outputs\n\n \\see OrtApi::Run\n\n \\param[in] session\n \\param[in] run_options\n \\param[in] binding_ptr\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub RunWithBinding: ::std::option::Option<
        unsafe extern "C" fn(
            session: *mut OrtSession,
            run_options: *const OrtRunOptions,
            binding_ptr: *const OrtIoBinding,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtIoBinding instance\n\n An IoBinding object allows one to bind pre-allocated ::OrtValue%s to input names.\n Thus if you want to use a raw on device buffer as input or output you can avoid\n extra copy during runtime.\n\n \\param[in] session\n \\param[out] out Newly created ::OrtIoBinding. Must be freed with OrtApi::ReleaseIoBinding\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateIoBinding: ::std::option::Option<
        unsafe extern "C" fn(session: *mut OrtSession, out: *mut *mut OrtIoBinding) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release an ::OrtIoBinding obtained from OrtApi::CreateIoBinding"]
    pub ReleaseIoBinding: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtIoBinding)>,
    #[doc = " \\brief Bind an ::OrtValue to an ::OrtIoBinding input\n\n When using OrtApi::RunWithBinding this value is used for the named input\n\n \\param[in] binding_ptr\n \\param[in] name Name for the model input\n \\param[in] val_ptr ::OrtValue of Tensor type.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub BindInput: ::std::option::Option<
        unsafe extern "C" fn(
            binding_ptr: *mut OrtIoBinding,
            name: *const ::std::os::raw::c_char,
            val_ptr: *const OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Bind an ::OrtValue to an ::OrtIoBinding output\n\n When using OrtApi::RunWithBinding this value is used for the named output\n\n \\param[in] binding_ptr\n \\param[in] name Null terminated string of the model output name\n \\param[in] val_ptr ::OrtValue of Tensor type.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub BindOutput: ::std::option::Option<
        unsafe extern "C" fn(
            binding_ptr: *mut OrtIoBinding,
            name: *const ::std::os::raw::c_char,
            val_ptr: *const OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Bind an ::OrtIoBinding output to a device\n\n Binds the ::OrtValue to a device which is specified by ::OrtMemoryInfo.\n You can either create an instance of ::OrtMemoryInfo with a device id or obtain one from the allocator that you have created/are using\n This is useful when one or more outputs have dynamic shapes and, it is hard to pre-allocate and bind a chunk of\n memory within ::OrtValue ahead of time.\n\n \\see OrtApi::RunWithBinding\n\n \\param[in] binding_ptr\n \\param[in] name Null terminated string of the device name\n \\param[in] mem_info_ptr\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub BindOutputToDevice: ::std::option::Option<
        unsafe extern "C" fn(
            binding_ptr: *mut OrtIoBinding,
            name: *const ::std::os::raw::c_char,
            mem_info_ptr: *const OrtMemoryInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the names of an ::OrtIoBinding's outputs\n\n Returns the names of the outputs in the order they were bound. This is useful after running the model\n with bound outputs because the returned names are in order in which output ::OrtValue are returned. This is useful if\n the order of outputs and their names is not known.\n\n \\param[in] binding_ptr\n \\param[in] allocator Allocator used to allocate continuous buffers for output strings and lengths.\n \\param[out] buffer Returns an array of non-null terminated UTF-8 strings. The number of strings stored is returned in the count parameter.\n   This buffer is allocated using `allocator` and must be freed using it.\n \\param[out] lengths Returns an array of `count` lengths of the strings returned in `buffer`\n   This buffer is allocated using `allocator` and must be freed using it.\n \\param[out] count Number of strings returned. If `binding_ptr` has no bound outputs, zero is returned,\n              no memory allocation is performed and buffer and lengths are set to nullptr.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetBoundOutputNames: ::std::option::Option<
        unsafe extern "C" fn(
            binding_ptr: *const OrtIoBinding,
            allocator: *mut OrtAllocator,
            buffer: *mut *mut ::std::os::raw::c_char,
            lengths: *mut *mut usize,
            count: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the output ::OrtValue objects from an ::OrtIoBinding\n\n Returns an array of pointers to individually allocated ::OrtValue%s that contain results of a model execution with OrtApi::RunWithBinding\n The array contains the same number of ::OrtValue%s and they are in the same order as they were bound with OrtApi::BindOutput\n or OrtApi::BindOutputToDevice.\n\n The returned ::OrtValue%s must be released using OrtApi::ReleaseValue after they are no longer needed.\n The array is allocated using the specified instance of the allocator and must be freed using the same allocator after\n all the ::OrtValue%s contained therein are individually released.\n\n \\param[in] binding_ptr\n \\param[in] allocator Allocator used to allocate output array\n \\param[out] output Set to the allocated array of allocated ::OrtValue outputs. Set to nullptr if there are 0 outputs.\n \\param[out] output_count Set to number of ::OrtValue%s returned\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetBoundOutputValues: ::std::option::Option<
        unsafe extern "C" fn(
            binding_ptr: *const OrtIoBinding,
            allocator: *mut OrtAllocator,
            output: *mut *mut *mut OrtValue,
            output_count: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Clears any previously set Inputs for an ::OrtIoBinding"]
    pub ClearBoundInputs:
        ::std::option::Option<unsafe extern "C" fn(binding_ptr: *mut OrtIoBinding)>,
    #[doc = " \\brief Clears any previously set Outputs for an ::OrtIoBinding"]
    pub ClearBoundOutputs:
        ::std::option::Option<unsafe extern "C" fn(binding_ptr: *mut OrtIoBinding)>,
    #[doc = " \\brief Direct memory access to a specified tensor element\n\n For example, given a tensor with shape of [3,224,224], a pointer to the element at location [2,150,128] can be retrieved\n\n This function only works for numeric type tensors (No strings, etc).\n This is a no-copy method whose returned pointer is valid until the passed in ::OrtValue is free'd.\n\n \\param[in] value\n \\param[in] location_values Pointer to an array of index values that specify an element's location relative to its shape\n \\param[in] location_values_count Number of elements in location_values. Must match the number of elements in the tensor's shape.\n \\param[out] out Set to a pointer to the element specified\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub TensorAt: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut OrtValue,
            location_values: *const i64,
            location_values_count: usize,
            out: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an allocator and register it with the ::OrtEnv\n\n Enables sharing the allocator between multiple sessions that use the same env instance.\n Lifetime of the created allocator will be valid for the duration of the environment.\n Returns an error if an allocator with the same ::OrtMemoryInfo is already registered.\n\n See https://onnxruntime.ai/docs/get-started/with-c.html for details.\n\n \\param[in] env ::OrtEnv instance\n \\param[in] mem_info\n \\param[in] arena_cfg Pass nullptr for defaults\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateAndRegisterAllocator: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut OrtEnv,
            mem_info: *const OrtMemoryInfo,
            arena_cfg: *const OrtArenaCfg,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set language projection\n\n Set the language projection for collecting telemetry data when Env is created.\n\n The default is ORT_PROJECTION_C, which means it will classify the language not in the list to C also.\n\n \\param[in] ort_env\n \\param[in] projection\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetLanguageProjection: ::std::option::Option<
        unsafe extern "C" fn(
            ort_env: *const OrtEnv,
            projection: OrtLanguageProjection,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Return the time that profiling was started\n\n \\note The timer precision varies per platform. On Windows and MacOS, the precision will be ~100ns\n\n \\param[in] session\n \\param[out] out nanoseconds of profiling's start time\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionGetProfilingStartTimeNs: ::std::option::Option<
        unsafe extern "C" fn(session: *const OrtSession, out: *mut u64) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set global intra-op thread count\n\n This configures the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools\n\n \\param[in] tp_options\n \\param[in] intra_op_num_threads Number of threads, special values:<br>\n    0 = Use default thread count<br>\n    1 = The invoking thread will be used; no threads will be created in the thread pool.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetGlobalIntraOpNumThreads: ::std::option::Option<
        unsafe extern "C" fn(
            tp_options: *mut OrtThreadingOptions,
            intra_op_num_threads: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set global inter-op thread count\n\n This configures the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools\n\n \\param[in] tp_options\n \\param[in] inter_op_num_threads Number of threads, special values:<br>\n    0 = Use default thread count<br>\n    1 = The invoking thread will be used; no threads will be created in the thread pool.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetGlobalInterOpNumThreads: ::std::option::Option<
        unsafe extern "C" fn(
            tp_options: *mut OrtThreadingOptions,
            inter_op_num_threads: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set global spin control options\n\n This will configure the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools.\n Allow spinning of thread pools when their queues are empty. This will set the value for both\n inter_op and intra_op threadpools.\n\n \\param[in] tp_options\n \\param[in] allow_spinning Valid values are 0 or 1.<br>\n   0 = It won't spin (recommended if CPU usage is high)<br>\n   1 = Threadpool will spin to wait for queue to become non-empty\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetGlobalSpinControl: ::std::option::Option<
        unsafe extern "C" fn(
            tp_options: *mut OrtThreadingOptions,
            allow_spinning: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Add a pre-allocated initializer to a session\n\n If a model contains an initializer with a name that is same as the name passed to this call,\n ORT will use this initializer instance instead of deserializing one from the model file. This\n is useful when you want to share the same initializer across sessions.\n\n \\param[in] options\n \\param[in] name Null terminated string of the initializer name\n \\param[in] val ::OrtValue containing the initializer. Its lifetime and the underlying initializer buffer must be\n   managed by the user (created using the OrtApi::CreateTensorWithDataAsOrtValue) and it must outlive the session object\n   to which it is added.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub AddInitializer: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            name: *const ::std::os::raw::c_char,
            val: *const OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Create a custom environment with global threadpools and logger that will be shared across sessions.\n Use this in conjunction with OrtApi::DisablePerSessionThreads or else the session will use\n its own thread pools.\n\n \\param[in] logging_function A pointer to a logging function.\n \\param[in] logger_param A pointer to arbitrary data passed as the ::OrtLoggingFunction `param` parameter to\n                         `logging_function`.\n \\param[in] log_severity_level The log severity level.\n \\param[in] logid The log identifier.\n \\param[in] tp_options\n \\param[out] out Newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateEnvWithCustomLoggerAndGlobalThreadPools: ::std::option::Option<
        unsafe extern "C" fn(
            logging_function: OrtLoggingFunction,
            logger_param: *mut ::std::os::raw::c_void,
            log_severity_level: OrtLoggingLevel,
            logid: *const ::std::os::raw::c_char,
            tp_options: *const OrtThreadingOptions,
            out: *mut *mut OrtEnv,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Append CUDA provider to session options\n\n If CUDA is not available (due to a non CUDA enabled build, or if CUDA is not installed on the system), this function will return failure.\n\n \\param[in] options\n \\param[in] cuda_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionOptionsAppendExecutionProvider_CUDA: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            cuda_options: *const OrtCUDAProviderOptions,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Append ROCM execution provider to the session options\n\n If ROCM is not available (due to a non ROCM enabled build, or if ROCM is not installed on the system), this function will return failure.\n\n \\param[in] options\n \\param[in] rocm_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionOptionsAppendExecutionProvider_ROCM: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            rocm_options: *const OrtROCMProviderOptions,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Append OpenVINO execution provider to the session options\n\n If OpenVINO is not available (due to a non OpenVINO enabled build, or if OpenVINO is not installed on the system), this function will fail.\n\n \\param[in] options\n \\param[in] provider_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionOptionsAppendExecutionProvider_OpenVINO: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            provider_options: *const OrtOpenVINOProviderOptions,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set threading flush-to-zero and denormal-as-zero\n\n Sets global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools.\n Flush-to-zero and denormal-as-zero are applied to threads in both intra and inter global thread pool.\n \\note This option is not needed if the models used have no denormals. Having no denormals is recommended as this option may hurt model accuracy.\n\n \\param[in] tp_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetGlobalDenormalAsZero: ::std::option::Option<
        unsafe extern "C" fn(tp_options: *mut OrtThreadingOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\deprecated Use OrtApi::CreateArenaCfgV2\n\n This will create the configuration of an arena that can eventually be used to define an arena based allocator's behavior\n\n \\param[in] max_mem Use 0 to allow ORT to choose the default\n \\param[in] arena_extend_strategy Use -1 to allow ORT to choose the default, 0 = kNextPowerOfTwo, 1 = kSameAsRequested\n \\param[in] initial_chunk_size_bytes Use -1 to allow ORT to choose the default\n \\param[in] max_dead_bytes_per_chunk Use -1 to allow ORT to choose the default\n \\param[in] out A pointer to an OrtArenaCfg instance\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateArenaCfg: ::std::option::Option<
        unsafe extern "C" fn(
            max_mem: usize,
            arena_extend_strategy: ::std::os::raw::c_int,
            initial_chunk_size_bytes: ::std::os::raw::c_int,
            max_dead_bytes_per_chunk: ::std::os::raw::c_int,
            out: *mut *mut OrtArenaCfg,
        ) -> OrtStatusPtr,
    >,
    pub ReleaseArenaCfg: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtArenaCfg)>,
    #[doc = " Use this to obtain the description of the graph present in the model\n (doc_string field of the GraphProto message within the ModelProto message).\n If it doesn't exist, an empty string will be returned.\n\n \\param[in] model_metadata An instance of ::OrtModelMetadata\n \\param[in] allocator Allocator used to allocate the string that will be returned back\n \\param[out] value Set to a null terminated string allocated using `allocator`.  The caller is responsible for freeing it using `allocator`\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub ModelMetadataGetGraphDescription: ::std::option::Option<
        unsafe extern "C" fn(
            model_metadata: *const OrtModelMetadata,
            allocator: *mut OrtAllocator,
            value: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Append TensorRT provider to session options\n\n If TensorRT is not available (due to a non TensorRT enabled build, or if TensorRT is not installed on the system), this function will return failure.\n\n \\param[in] options\n \\param[in] tensorrt_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionOptionsAppendExecutionProvider_TensorRT: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            tensorrt_options: *const OrtTensorRTProviderOptions,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set current GPU device ID\n\n Set the current device id of the GPU execution provider (CUDA/tensorrt/rocm). The device id should be less\n than the total number of devices available. This is only useful when multiple-GPUs are installed and it is\n required to restrict execution to a single GPU.\n\n \\param[in] device_id\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetCurrentGpuDeviceId: ::std::option::Option<
        unsafe extern "C" fn(device_id: ::std::os::raw::c_int) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get current GPU device ID\n\n Get the current device id of the GPU execution provider (CUDA/tensorrt/rocm).\n\n \\see OrtApi::SetCurrentGpuDeviceId\n\n \\param[out] device_id\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetCurrentGpuDeviceId: ::std::option::Option<
        unsafe extern "C" fn(device_id: *mut ::std::os::raw::c_int) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Fetch an array of int64_t values stored as an attribute in the graph node\n\n\n If `out` is nullptr, the value of `size` is set to the true size of the attribute\n array's size, and a success status is returned.\n\n If the `size` parameter is greater than or equal to the actual attribute array's size,\n the value of `size` is set to the true size of the attribute array's size,\n the provided memory is filled with the attribute's contents,\n and a success status is returned.\n\n If the `size` parameter is less than the actual attribute array's size and `out`\n is not nullptr, the value of `size` is set to the true size of the attribute array's size\n and a failure status is returned.)\n\n \\param[in] info instance\n \\param[in] name name of the attribute to be parsed\n \\param[out] out pointer to memory where the attribute's contents are to be stored\n \\param[in, out] size actual size of attribute array\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub KernelInfoGetAttributeArray_float: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            name: *const ::std::os::raw::c_char,
            out: *mut f32,
            size: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Fetch an array of int64_t values stored as an attribute in the graph node\n\n If `out` is nullptr, the value of `size` is set to the true size of the attribute\n array's size, and a success status is returned.\n\n If the `size` parameter is greater than or equal to the actual attribute array's size,\n the value of `size` is set to the true size of the attribute array's size,\n the provided memory is filled with the attribute's contents,\n and a success status is returned.\n\n If the `size` parameter is less than the actual attribute array's size and `out`\n is not nullptr, the value of `size` is set to the true size of the attribute array's size\n and a failure status is returned.)\n\n \\param[in] info instance\n \\param[in] name name of the attribute to be parsed\n \\param[out] out pointer to memory where the attribute's contents are to be stored\n \\param[in, out] size actual size of attribute array\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub KernelInfoGetAttributeArray_int64: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            name: *const ::std::os::raw::c_char,
            out: *mut i64,
            size: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtArenaCfg\n\n Create the configuration of an arena that can eventually be used to define an arena based allocator's behavior.\n\n Supported keys are (See https://onnxruntime.ai/docs/get-started/with-c.html for details on what the\n following parameters mean and how to choose these values.):\n \"max_mem\": Maximum memory that can be allocated by the arena based allocator.\n  Use 0 for ORT to pick the best value. Default is 0.\n \"arena_extend_strategy\": 0 = kNextPowerOfTwo, 1 = kSameAsRequested.\n  Use -1 to allow ORT to choose the default.\n \"initial_chunk_size_bytes\": (Possible) Size of the first allocation in the arena.\n  Only relevant if arena strategy is `kNextPowerOfTwo`. Use -1 to allow ORT to choose the default.\n  Ultimately, the first allocation size is determined by the allocation memory request.\n \"max_dead_bytes_per_chunk\": Threshold of unused memory in an allocated chunk of arena memory after\n  crossing which the current chunk is chunked into 2.\n \"initial_growth_chunk_size_bytes\": (Possible) Size of the second allocation in the arena.\n  Only relevant if arena strategy is `kNextPowerOfTwo`. Use -1 to allow ORT to choose the default.\n \"max_power_of_two_extend_bytes\": The maximum enxtend size if arena strategy is `kNextPowerOfTwo`.\n  It is not an allocation limit, it is only a limit for extention when requested byte is less than the limit.\n  When requested bytes is more than the limit, allocator will still return as requested.\n  Use -1 to allow ORT to choose the default 1GB for max_power_of_two_extend_bytes.\n  Ultimately, the allocation size is determined by the allocation memory request.\n  Further allocation sizes are governed by the arena extend strategy.\n\n \\param[in] arena_config_keys Keys to configure the arena\n \\param[in] arena_config_values Values to configure the arena\n \\param[in] num_keys Number of keys in `arena_config_keys` and `arena_config_values`\n \\param[out] out Newly created ::OrtArenaCfg. Must be freed with OrtApi::ReleaseArenaCfg\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateArenaCfgV2: ::std::option::Option<
        unsafe extern "C" fn(
            arena_config_keys: *const *const ::std::os::raw::c_char,
            arena_config_values: *const usize,
            num_keys: usize,
            out: *mut *mut OrtArenaCfg,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set a single run configuration entry as a pair of strings\n\n If a configuration with same key exists, this will overwrite the configuration with the given config_value\n\n The config_key and the format of config_value are defined in onnxruntime_run_options_config_keys.h\n\n \\param[in] options\n \\param[in] config_key A null terminated string representation of the config key\n \\param[in] config_value  A null terminated string representation of the config value\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub AddRunConfigEntry: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtRunOptions,
            config_key: *const ::std::os::raw::c_char,
            config_value: *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtPrepackedWeightsContainer\n\n This container will hold pre-packed buffers of shared initializers for sharing between sessions\n (i.e.) if there are shared initializers that can be shared between sessions, the pre-packed buffers\n of these (if any) may possibly be shared to provide memory footprint savings. Pass this container\n to sessions that you would like to share pre-packed buffers of shared initializers at session\n creation time.\n\n  \\param[out] out Newly created ::OrtPrepackedWeightsContainer. Must be freed with OrtApi::ReleasePrepackedWeightsContainer\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreatePrepackedWeightsContainer: ::std::option::Option<
        unsafe extern "C" fn(out: *mut *mut OrtPrepackedWeightsContainer) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release OrtPrepackedWeightsContainer instance\n\n \\note instance must not be released until the sessions using it are released"]
    pub ReleasePrepackedWeightsContainer:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtPrepackedWeightsContainer)>,
    #[doc = " \\brief Create session with prepacked weights container\n\n Same functionality offered by OrtApi::CreateSession except that a container that contains\n pre-packed weights' buffers is written into/read from by the created session.\n This is useful when used in conjunction with OrtApi::AddInitializer which injects\n shared initializer info into sessions. Wherever possible, the pre-packed versions of these\n shared initializers are cached in this container so that multiple sessions can just re-use\n these instead of duplicating these in memory.\n\n \\param[in] env OrtEnv instance instance\n \\param[in] model_path Null terminated string of the path (wchar on Windows, char otherwise)\n \\param[in] options\n \\param[in] prepacked_weights_container\n \\param[out] out Newly created ::OrtSession. Must be freed with OrtApi::ReleaseSession\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateSessionWithPrepackedWeightsContainer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *const OrtEnv,
            model_path: *const wchar_t,
            options: *const OrtSessionOptions,
            prepacked_weights_container: *mut OrtPrepackedWeightsContainer,
            out: *mut *mut OrtSession,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create session from memory with prepacked weights container\n\n Same functionality offered by OrtApi::CreateSessionFromArray except that a container that contains\n pre-packed weights' buffers is written into/read from by the created session.\n This is useful when used in conjunction with OrtApi::AddInitializer which injects\n shared initializer info into sessions. Wherever possible, the pre-packed versions of these\n shared initializers are cached in this container so that multiple sessions can just re-use\n these instead of duplicating these in memory.\n\n \\param[in] env\n \\param[in] model_data Array of bytes holding the model\n \\param[in] model_data_length Number of bytes in `model_data_model`\n \\param[in] options\n \\param[in] prepacked_weights_container\n \\param[out] out Newly created ::OrtSession. Must be freed with OrtApi::ReleaseSession\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateSessionFromArrayWithPrepackedWeightsContainer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *const OrtEnv,
            model_data: *const ::std::os::raw::c_void,
            model_data_length: usize,
            options: *const OrtSessionOptions,
            prepacked_weights_container: *mut OrtPrepackedWeightsContainer,
            out: *mut *mut OrtSession,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Append TensorRT execution provider to the session options\n\n If TensorRT is not available (due to a non TensorRT enabled build), this function will return failure.\n\n This is slightly different from OrtApi::SessionOptionsAppendExecutionProvider_TensorRT, it takes an\n ::OrtTensorRTProviderOptions which is publicly defined. This takes an opaque ::OrtTensorRTProviderOptionsV2\n which must be created with OrtApi::CreateTensorRTProviderOptions.\n\n For OrtApi::SessionOptionsAppendExecutionProvider_TensorRT, the user needs to instantiate ::OrtTensorRTProviderOptions\n as well as allocate/release buffers for some members of ::OrtTensorRTProviderOptions.\n Here, OrtApi::CreateTensorRTProviderOptions and Ortapi::ReleaseTensorRTProviderOptions will do the memory management for you.\n\n \\param[in] options\n \\param[in] tensorrt_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionOptionsAppendExecutionProvider_TensorRT_V2: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            tensorrt_options: *const OrtTensorRTProviderOptionsV2,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an OrtTensorRTProviderOptionsV2\n\n \\param[out] out Newly created ::OrtTensorRTProviderOptionsV2. Must be released with OrtApi::ReleaseTensorRTProviderOptions\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateTensorRTProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(out: *mut *mut OrtTensorRTProviderOptionsV2) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set options in a TensorRT Execution Provider.\n\n Please refer to https://onnxruntime.ai/docs/execution-providers/TensorRT-ExecutionProvider.html#cc\n to know the available keys and values. Key should be in null terminated string format of the member of ::OrtTensorRTProviderOptionsV2\n and value should be its related range.\n\n For example, key=\"trt_max_workspace_size\" and value=\"2147483648\"\n\n \\param[in] tensorrt_options\n \\param[in] provider_options_keys Array of UTF-8 null-terminated string for provider options keys\n \\param[in] provider_options_values Array of UTF-8 null-terminated string for provider options values\n \\param[in] num_keys Number of elements in the `provider_option_keys` and `provider_options_values` arrays\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub UpdateTensorRTProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(
            tensorrt_options: *mut OrtTensorRTProviderOptionsV2,
            provider_options_keys: *const *const ::std::os::raw::c_char,
            provider_options_values: *const *const ::std::os::raw::c_char,
            num_keys: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get serialized TensorRT provider options string.\n\n For example, \"trt_max_workspace_size=2147483648;trt_max_partition_iterations=10;trt_int8_enable=1;......\"\n\n \\param tensorrt_options - OrtTensorRTProviderOptionsV2 instance\n \\param allocator - a ptr to an instance of OrtAllocator obtained with OrtApi::CreateAllocator or OrtApi::GetAllocatorWithDefaultOptions\n                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.\n \\param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetTensorRTProviderOptionsAsString: ::std::option::Option<
        unsafe extern "C" fn(
            tensorrt_options: *const OrtTensorRTProviderOptionsV2,
            allocator: *mut OrtAllocator,
            ptr: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release an ::OrtTensorRTProviderOptionsV2\n\n \\note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does"]
    pub ReleaseTensorRTProviderOptions:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtTensorRTProviderOptionsV2)>,
    #[doc = " \\brief Enable custom operators\n\n See onnxruntime-extensions: https://github.com/microsoft/onnxruntime-extensions.git\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub EnableOrtCustomOps: ::std::option::Option<
        unsafe extern "C" fn(options: *mut OrtSessionOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Register a custom allocator\n\n Enables sharing between multiple sessions that use the same env instance.\n Returns an error if an allocator with the same ::OrtMemoryInfo is already registered.\n\n The behavior of this is exactly the same as OrtApi::CreateAndRegisterAllocator except\n instead of ORT creating an allocator based on provided info, in this case\n ORT uses the user-provided custom allocator.\n See https://onnxruntime.ai/docs/get-started/with-c.html for details.\n\n \\param[in] env\n \\param[in] allocator User provided allocator\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub RegisterAllocator: ::std::option::Option<
        unsafe extern "C" fn(env: *mut OrtEnv, allocator: *mut OrtAllocator) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Unregister a custom allocator\n\n It is an error if you provide an ::OrtMemoryInfo not corresponding to any\n registered allocators for sharing.\n\n \\param[in] env\n \\param[in] mem_info\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub UnregisterAllocator: ::std::option::Option<
        unsafe extern "C" fn(env: *mut OrtEnv, mem_info: *const OrtMemoryInfo) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Sets *out to 1 iff an ::OrtValue is a SparseTensor, and 0 otherwise\n\n \\param[in] value existing ::OrtValue\n \\param[out] out unless an error occurs, contains 1 iff the value contains an instance\n  of sparse tensor or 0 otherwise.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub IsSparseTensor: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const OrtValue,
            out: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an ::OrtValue with a sparse tensor that is empty.\n\n Use FillSparseTensor<Format>() functions to populate sparse tensor with non-zero values and\n format specific indices data.\n Use ReleaseValue to destroy the sparse tensor, this will also release the buffer inside the output value\n if any was allocated.\n \\param[in,out] allocator allocator to use when performing an allocation. Allocation will be performed\n   by FillSparseTensor<Format>() APIs. The lifespan of the allocator instance must eclipse the lifespan\n   this sparse tensor instance as the same allocator will be used to free memory.\n \\param[in] dense_shape shape of the original dense tensor\n \\param[in] dense_shape_len number of shape dimensions being passed\n \\param[in] type must be one of TENSOR_ELEMENT_DATA_TYPE_xxxx\n \\param[out] out Should be freed by calling ReleaseValue\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateSparseTensorAsOrtValue: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut OrtAllocator,
            dense_shape: *const i64,
            dense_shape_len: usize,
            type_: ONNXTensorElementDataType,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.\n This will allocate required memory and copy the supplied NNZ values and COO indices into that memory allocation.\n Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.\n\n \\param[in,out] ort_value ::OrtValue to populate with data\n \\param[in] data_mem_info serves to identify the location of the data to be copied. If the allocator specified\n  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.\n  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.\n \\param[in] values_shape pointer to values shape array\n \\param[in] values_shape_len length of the values_shape\n \\param[in] values pointer to an array of values. For strings, pass const char**.\n \\param[in] indices_data pointer to a location of COO indices\n \\param[in] indices_num number of COO indices\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub FillSparseTensorCoo: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *mut OrtValue,
            data_mem_info: *const OrtMemoryInfo,
            values_shape: *const i64,
            values_shape_len: usize,
            values: *const ::std::os::raw::c_void,
            indices_data: *const i64,
            indices_num: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.\n This will allocate required memory and copy the supplied NNZ values and CSR indices into that memory allocation.\n Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.\n\n \\param[in,out] ort_value ::OrtValue to populate with data\n \\param[in] data_mem_info serves to identify the location of the data to be copied. If the allocator specified\n  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.\n  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.\n \\param[in] values_shape pointer to values shape array\n \\param[in] values_shape_len length of the values_shape\n \\param[in] values - pointer to an array of values. For strings, pass const char**.\n \\param[in] inner_indices_data pointer to a location of CSR inner indices\n \\param[in] inner_indices_num number of CSR inner indices\n \\param[in] outer_indices_data pointer to a location of CSR outer indices\n \\param[in] outer_indices_num number of CSR outer indices\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub FillSparseTensorCsr: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *mut OrtValue,
            data_mem_info: *const OrtMemoryInfo,
            values_shape: *const i64,
            values_shape_len: usize,
            values: *const ::std::os::raw::c_void,
            inner_indices_data: *const i64,
            inner_indices_num: usize,
            outer_indices_data: *const i64,
            outer_indices_num: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.\n This will allocate required memory and copy the supplied NNZ values and BlockSparse indices into that memory allocation.\n Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.\n\n \\param[in,out] ort_value ::OrtValue to populate with data\n \\param[in] data_mem_info serves to identify the location of the data to be copied. If the allocator specified\n  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.\n  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.\n \\param[in] values_shape\n \\param[in] values_shape_len\n \\param[in] values structure with values information\n \\param[in] indices_shape_data pointer to a location of indices shape\n \\param[in] indices_shape_len length of the block sparse indices shape\n \\param[in] indices_data pointer to a location of indices data. Shape will determine the length of the indices data.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub FillSparseTensorBlockSparse: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *mut OrtValue,
            data_mem_info: *const OrtMemoryInfo,
            values_shape: *const i64,
            values_shape_len: usize,
            values: *const ::std::os::raw::c_void,
            indices_shape_data: *const i64,
            indices_shape_len: usize,
            indices_data: *const i32,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Create an ::OrtValue with a sparse tensor. This is the first step.\n Next, use Use<Format>Indices() functions to supply sparse tensor with\n format specific indices data and set its sparse format to a specific enum value.\n This will not perform memory allocations. It will\n use supplied user buffer which should outlive the created sparse tensor.\n Use OrtApi::ReleaseValue to destroy the sparse tensor. It would not release the supplied values buffer.\n This function can not be used to map strings from the user allocated memory. Strings must always be copied\n and have UTF-8 encoding. Therefore, use OrtApi::CreateSparseTensorAsOrtValue above and then fill it with data\n using appropriate Make*() function.\n\n \\param[in] info memory info where sparse values reside.\n \\param[in,out] p_data pointer to a user allocated buffer with values. To create a full sparse tensor with no non-zero\n   values, pass nullptr\n \\param[in] dense_shape shape of the original dense tensor\n \\param[in] dense_shape_len number of shape dimensions being passed\n \\param[in] values_shape shape of the values data. To create a fully sparse tensor with no non-zero values,\n   pass {0} shape.\n \\param[in] values_shape_len number of values shape dimensions\n \\param[in] type must be one of TENSOR_ELEMENT_DATA_TYPE_xxxx\n \\param[out] out Should be freed by calling ReleaseValue\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub CreateSparseTensorWithValuesAsOrtValue: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtMemoryInfo,
            p_data: *mut ::std::os::raw::c_void,
            dense_shape: *const i64,
            dense_shape_len: usize,
            values_shape: *const i64,
            values_shape_len: usize,
            type_: ONNXTensorElementDataType,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " This assigns Coo format indices to the SparseTensor that was created by\n OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to\n ORT_SPARSE_COO. This will not allocate any additional memory for data. The life span of\n indices_data buffer should eclipse the life span of this ::OrtValue.\n\n \\param[in,out] ort_value ::OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue\n \\param[in,out] indices_data pointer to a user pre-allocated buffer or nullptr for fully sparse tensors.\n \\param[in] indices_num  number of COO indices. Should either be 0 for fully sparse tensors, be equal\n  to the number of nnz values specified to OrtApi::CreateSparseTensorWithValuesAsOrtValue for 1-D {nnz} indices or\n  be twice as number of nnz values for a  2-D indices {nnz, 2}\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub UseCooIndices: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *mut OrtValue,
            indices_data: *mut i64,
            indices_num: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " The assigns CSR format indices to the SparseTensor that was created by\n OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to\n ORT_SPARSE_CSRC. This will not allocate any additional memory for data. The life spans of\n inner_data and outer_data buffers should eclipse the life span of this ::OrtValue.\n\n \\param[in,out] ort_value ::OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue\n \\param[in,out] inner_data pointer to a user pre-allocated buffer or nullptr for fully sparse tensors.\n \\param[in] inner_num  number of inner CSR indices. Should either be 0 for fully sparse tensors or be equal\n to the number of nnz values specified to OrtApi::CreateSparseTensorWithValuesAsOrtValue.\n \\param[in,out] outer_data pointer to user pre-allocated buffer or nullptr for fully sparse tensors.\n \\param[in] outer_num number of CSR outer indices. Should either be 0 for fully sparse tensors or\n equal to rows + 1 of the dense shape.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub UseCsrIndices: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *mut OrtValue,
            inner_data: *mut i64,
            inner_num: usize,
            outer_data: *mut i64,
            outer_num: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " The assigns BlockSparse format indices to the SparseTensor that was created by\n OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to\n ORT_SPARSE_BLOCK_SPARSE. This will not allocate any additional memory for data. The life span of\n indices_data buffer must eclipse the lifespan of this ::OrtValue.\n\n \\param[in,out] ort_value OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue\n \\param[in] indices_shape pointer to indices shape. Use {0} for fully sparse tensors\n \\param[in] indices_shape_len length of the indices shape\n \\param[in,out] indices_data pointer to user pre-allocated buffer or nullptr for fully sparse tensors.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub UseBlockSparseIndices: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *mut OrtValue,
            indices_shape: *const i64,
            indices_shape_len: usize,
            indices_data: *mut i32,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Returns sparse tensor format enum iff a given ort value contains an instance of sparse tensor.\n\n \\param[in] ort_value ::OrtValue that contains an instance of sparse tensor\n \\param[out] out pointer to out parameter\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetSparseTensorFormat: ::std::option::Option<
        unsafe extern "C" fn(ort_value: *const OrtValue, out: *mut OrtSparseFormat) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Returns data type and shape of sparse tensor values (nnz) iff ::OrtValue contains a SparseTensor.\n\n \\param[in] ort_value An ::OrtValue that contains a fully constructed sparse tensor\n \\param[out] out Must be freed by OrtApi::ReleaseTensorTypeAndShapeInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetSparseTensorValuesTypeAndShape: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *const OrtValue,
            out: *mut *mut OrtTensorTypeAndShapeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Returns numeric data for sparse tensor values (nnz). For string values use GetStringTensor*().\n\n \\param[in] ort_value an instance of ::OrtValue containing sparse tensor\n \\param[out] out returns a pointer to values data.  Do not attempt to free this ptr.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetSparseTensorValues: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *const OrtValue,
            out: *mut *const ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Returns data type, shape for the type of indices specified by indices_format.\n\n \\param[in] ort_value ::OrtValue containing sparse tensor.\n \\param[in] indices_format One of the indices formats. It is an error to request a format that the sparse\n tensor does not contain.\n \\param[out] out an instance of ::OrtTensorTypeAndShapeInfo. Must be freed by OrtApi::ReleaseTensorTypeAndShapeInfo\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetSparseTensorIndicesTypeShape: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *const OrtValue,
            indices_format: OrtSparseIndicesFormat,
            out: *mut *mut OrtTensorTypeAndShapeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Returns indices data for the type of the indices specified by indices_format\n\n \\param[in] ort_value ::OrtValue containing sparse tensor.\n \\param[in] indices_format One of the indices formats. It is an error to request a format that the sparse tensor does not contain.\n \\param[out] num_indices Pointer to where the number of indices entries is returned\n \\param[out] indices Returned pointer to the indices data. Do not free the returned pointer as it refers to internal data owned by the ::OrtValue\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetSparseTensorIndices: ::std::option::Option<
        unsafe extern "C" fn(
            ort_value: *const OrtValue,
            indices_format: OrtSparseIndicesFormat,
            num_indices: *mut usize,
            indices: *mut *const ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Sets out to 1 iff an optional type OrtValue has an element, 0 otherwise (OrtValue is None)\n Use this API to find if the optional type OrtValue is None or not.\n If the optional type OrtValue is not None, use the OrtValue just like any other OrtValue.\n For example, if you get an OrtValue that corresponds to Optional(tensor) and\n if HasValue() returns true, use it as tensor and so on.\n\n \\param[in] value Input OrtValue.\n \\param[out] out indicating if the input OrtValue contains data (1) or if it is a None (0)\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub HasValue: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const OrtValue,
            out: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Used for custom operators, gets the GPU compute stream to use to launch the custom a GPU kernel\n   \\see ::OrtCustomOp\n \\param[in]  context OrtKernelContext instance\n \\param[out] out Returns pointer to a GPU compute stream that can be used to launch the custom GPU kernel.\n             If retrieving the GPU compute stream is not relevant (GPU not enabled in the build, kernel partitioned to\n             some other EP), then a nullptr is returned as the output param.\n             Do not free or mutate the returned pointer as it refers to internal data owned by the underlying session.\n             Only use it for custom kernel launching.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub KernelContext_GetGPUComputeStream: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtKernelContext,
            out: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " @}\n \\name GetTensorMemoryInfo\n @{\n** \\brief Returns a pointer to the ::OrtMemoryInfo of a Tensor\n* \\param[in] value ::OrtValue containing tensor.\n* \\param[out] mem_info ::OrtMemoryInfo of the tensor. Do NOT free the returned pointer. It is valid for the lifetime of the ::OrtValue\n*\n* \\snippet{doc} snippets.dox OrtStatus Return Value\n*/"]
    pub GetTensorMemoryInfo: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const OrtValue,
            mem_info: *mut *const OrtMemoryInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " @}\n \\name GetExecutionProviderApi\n @{\n** \\brief Get a pointer to the requested version of the Execution Provider specific\n* API extensions to the OrtApi\n* \\param[in] provider_name The name of the execution provider name. Currently only the following\n* values are supported: \"DML\".\n* \\param[in] version Must be ::ORT_API_VERSION.\n* \\param[out] provider_api A void pointer containing a reference to the execution provider versioned api structure.\n* For example, the provider_api pointer can be cast to the OrtDmlApi* when the provider_name is \"DML\".\n*\n* \\snippet{doc} snippets.dox OrtStatus Return Value\n*/"]
    pub GetExecutionProviderApi: ::std::option::Option<
        unsafe extern "C" fn(
            provider_name: *const ::std::os::raw::c_char,
            version: u32,
            provider_api: *mut *const ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\name SessionOptions\n @{\n** \\brief Set custom thread creation function\n*\n* \\param[in] options Session options\n* \\param[in] ort_custom_create_thread_fn Custom thread creation function\n*\n* \\snippet{doc} snippets.dox OrtStatus Return Value\n*/"]
    pub SessionOptionsSetCustomCreateThreadFn: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            ort_custom_create_thread_fn: OrtCustomCreateThreadFn,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set creation options for custom thread\n\n \\param[in] options Session options\n \\param[in] ort_custom_thread_creation_options Custom thread creation options (can be nullptr)\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionOptionsSetCustomThreadCreationOptions: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            ort_custom_thread_creation_options: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set custom thread join function\n\n \\param[in] options Session options\n \\param[in] ort_custom_join_thread_fn Custom join thread function, must not be nullptr when ort_custom_create_thread_fn is set\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionOptionsSetCustomJoinThreadFn: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            ort_custom_join_thread_fn: OrtCustomJoinThreadFn,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\name OrtThreadingOptions\n @{\n** \\brief Set custom thread creation function for global thread pools\n*\n* \\param[inout] tp_options\n* \\param[in] ort_custom_create_thread_fn Custom thread creation function\n*\n* \\snippet{doc} snippets.dox OrtStatus Return Value\n*/"]
    pub SetGlobalCustomCreateThreadFn: ::std::option::Option<
        unsafe extern "C" fn(
            tp_options: *mut OrtThreadingOptions,
            ort_custom_create_thread_fn: OrtCustomCreateThreadFn,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set custom thread creation options for global thread pools\n\n \\param[inout] tp_options\n \\param[in] ort_custom_thread_creation_options Custom thread creation options (can be nullptr)\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetGlobalCustomThreadCreationOptions: ::std::option::Option<
        unsafe extern "C" fn(
            tp_options: *mut OrtThreadingOptions,
            ort_custom_thread_creation_options: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set custom thread join function for global thread pools\n\n \\param[inout] tp_options\n \\param[in] ort_custom_join_thread_fn Custom thread join function, must not be nullptr when global ort_custom_create_thread_fn is set\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SetGlobalCustomJoinThreadFn: ::std::option::Option<
        unsafe extern "C" fn(
            tp_options: *mut OrtThreadingOptions,
            ort_custom_join_thread_fn: OrtCustomJoinThreadFn,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Synchronize bound inputs. The call may be necessary for some providers, such as cuda,\n   in case the system that allocated bound memory operated on a different stream. However, the\n   operation is provider specific and could be a no-op.\n\n \\param[inout] binding_ptr\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SynchronizeBoundInputs:
        ::std::option::Option<unsafe extern "C" fn(binding_ptr: *mut OrtIoBinding) -> OrtStatusPtr>,
    #[doc = " \\brief Synchronize bound outputs. The call may be necessary for some providers, such as cuda,\n   in case the system that allocated bound memory operated on a different stream. However, the\n   operation is provider specific and could be a no-op.\n\n \\param[inout] binding_ptr\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SynchronizeBoundOutputs:
        ::std::option::Option<unsafe extern "C" fn(binding_ptr: *mut OrtIoBinding) -> OrtStatusPtr>,
    #[doc = " \\brief Append CUDA execution provider to the session options\n\n If CUDA is not available (due to a non CUDA enabled build), this function will return failure.\n\n This is slightly different from OrtApi::SessionOptionsAppendExecutionProvider_CUDA, it takes an\n ::OrtCUDAProviderOptions which is publicly defined. This takes an opaque ::OrtCUDAProviderOptionsV2\n which must be created with OrtApi::CreateCUDAProviderOptions.\n\n For OrtApi::SessionOptionsAppendExecutionProvider_CUDA, the user needs to instantiate ::OrtCUDAProviderOptions\n as well as allocate/release buffers for some members of ::OrtCUDAProviderOptions.\n Here, OrtApi::CreateCUDAProviderOptions and Ortapi::ReleaseCUDAProviderOptions will do the memory management for you.\n\n \\param[in] options\n \\param[in] cuda_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.11."]
    pub SessionOptionsAppendExecutionProvider_CUDA_V2: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            cuda_options: *const OrtCUDAProviderOptionsV2,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an OrtCUDAProviderOptionsV2\n\n \\param[out] out Newly created ::OrtCUDAProviderOptionsV2. Must be released with OrtApi::ReleaseCudaProviderOptions\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.11."]
    pub CreateCUDAProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(out: *mut *mut OrtCUDAProviderOptionsV2) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set options in a CUDA Execution Provider.\n\n Please refer to https://onnxruntime.ai/docs/execution-providers/CUDA-ExecutionProvider.html#configuration-options\n to know the available keys and values. Key should be in null terminated string format of the member of ::OrtCUDAProviderOptionsV2\n and value should be its related range.\n\n For example, key=\"device_id\" and value=\"0\"\n\n \\param[in] cuda_options\n \\param[in] provider_options_keys Array of UTF-8 null-terminated string for provider options keys\n \\param[in] provider_options_values Array of UTF-8 null-terminated string for provider options values\n \\param[in] num_keys Number of elements in the `provider_option_keys` and `provider_options_values` arrays\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.11."]
    pub UpdateCUDAProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(
            cuda_options: *mut OrtCUDAProviderOptionsV2,
            provider_options_keys: *const *const ::std::os::raw::c_char,
            provider_options_values: *const *const ::std::os::raw::c_char,
            num_keys: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Get serialized CUDA provider options string.\n\n For example, \"device_id=0;arena_extend_strategy=0;......\"\n\n \\param cuda_options - OrtCUDAProviderOptionsV2 instance\n \\param allocator - a ptr to an instance of OrtAllocator obtained with CreateAllocator() or GetAllocatorWithDefaultOptions()\n                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.\n \\param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.11."]
    pub GetCUDAProviderOptionsAsString: ::std::option::Option<
        unsafe extern "C" fn(
            cuda_options: *const OrtCUDAProviderOptionsV2,
            allocator: *mut OrtAllocator,
            ptr: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release an ::OrtCUDAProviderOptionsV2\n\n \\note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does\n\n \\since Version 1.11."]
    pub ReleaseCUDAProviderOptions:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtCUDAProviderOptionsV2)>,
    #[doc = " \\brief Append MIGraphX provider to session options\n\n If MIGraphX is not available (due to a non MIGraphX enabled build, or if MIGraphX is not installed on the system), this function will return failure.\n\n \\param[in] options\n \\param[in] migraphx_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.11."]
    pub SessionOptionsAppendExecutionProvider_MIGraphX: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            migraphx_options: *const OrtMIGraphXProviderOptions,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Replace initialized Tensors with external data with the data provided in initializers.\n\n The function will find the initialized TensorProtos with external data in the graph with the provided names and\n replace them with the provided tensors. The API verifies that the TensorProto being replaced\n has an external data reference and has the same name, dimensions and data type as its replacement. The replacement\n will occur before any of the optimizations take place. The data will be copied into the graph\n since TensorProto can't refer to the user provided buffers.\n\n Once the model has been loaded, the OrtValue(s) added to SessionOptions instance will be removed\n from the internal SessionOptions copy to save memory, the user provided buffers can then be deallocated\n and the SessionOptions instance that refers to them can be destroyed.\n\n \\param[in] options\n \\param[in] initializer_names Array of null terminated UTF-8 encoded strings of the initializers names.\n \\param[in] initializers Array of ::OrtValue type\n \\param[in] initializers_num Number of elements in the initializer_names and initializers\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.12."]
    pub AddExternalInitializers: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            initializer_names: *const *const ::std::os::raw::c_char,
            initializers: *const *const OrtValue,
            initializers_num: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief: Create attribute of onnxruntime operator\n\n \\param[in] name Name of the attribute\n \\param[in] data Data content of the attribute\n \\param[in] len Number of bytes stored in data\n \\param[in] type Data type\n \\param[out] op_attr Attribute that has been created, which must be released by OrtApi::ReleaseOpAttr\n\n \\since Version 1.12."]
    pub CreateOpAttr: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            data: *const ::std::os::raw::c_void,
            len: ::std::os::raw::c_int,
            type_: OrtOpAttrType,
            op_attr: *mut *mut OrtOpAttr,
        ) -> OrtStatusPtr,
    >,
    pub ReleaseOpAttr: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtOpAttr)>,
    #[doc = " \\brief: Create onnxruntime native operator\n\n \\param[in] info Kernel info\n \\param[in] op_name Operator name\n \\param[in] domain Operator domain\n \\param[in] version Operator opset version\n \\param[in] type_constraint_names Name of the type contraints, such as \"T\" or \"T1\"\n \\param[in] type_constraint_values Type of each contraints\n \\param[in] type_constraint_count Number of contraints\n \\param[in] attr_values Attributes used to initialize the operator\n \\param[in] attr_count Number of the attributes\n \\param[in] input_count Number of inputs\n \\param[in] output_count Number of outputs\n \\param[out] ort_op Operator that has been created\n\n \\since Version 1.12."]
    pub CreateOp: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            op_name: *const ::std::os::raw::c_char,
            domain: *const ::std::os::raw::c_char,
            version: ::std::os::raw::c_int,
            type_constraint_names: *mut *const ::std::os::raw::c_char,
            type_constraint_values: *const ONNXTensorElementDataType,
            type_constraint_count: ::std::os::raw::c_int,
            attr_values: *const *const OrtOpAttr,
            attr_count: ::std::os::raw::c_int,
            input_count: ::std::os::raw::c_int,
            output_count: ::std::os::raw::c_int,
            ort_op: *mut *mut OrtOp,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief: Invoke the operator created by OrtApi::CreateOp\n The inputs must follow the order as specified in onnx specification\n\n \\param[in] context Kernel context\n \\param[in] ort_op Operator that has been created\n \\param[in] input_values Array of inputs\n \\param[in] input_count Number of inputs\n \\param[in] output_values Array of outputs\n \\param[in] output_count Number of outputs\n\n \\since Version 1.12."]
    pub InvokeOp: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtKernelContext,
            ort_op: *const OrtOp,
            input_values: *const *const OrtValue,
            input_count: ::std::os::raw::c_int,
            output_values: *const *mut OrtValue,
            output_count: ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    pub ReleaseOp: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtOp)>,
    #[doc = " \\brief: Append execution provider to the session options.\n \\param[in] options\n \\param[in] provider_name - provider to add.\n \\param[in] provider_options_keys - keys to configure the provider options\n \\param[in] provider_options_values - values to configure the provider options\n \\param[in] num_keys - number of keys passed in\n\n Currently supported providers:\n   QNN\n   SNPE\n   XNNPACK\n\n Note: If an execution provider has a dedicated SessionOptionsAppendExecutionProvider_<provider name> function\n       that should be used to add it.\n\n QNN supported keys:\n   \"backend_path\": file path to QNN backend library.\n   \"profiling_level\": QNN profiling level, options: \"off\", \"basic\", \"detailed\". Default to off.\n   \"rpc_control_latency\": QNN RPC control latency.\n   \"vtcm_mb\": QNN VTCM size in MB. default to 0(not set).\n   \"htp_performance_mode\": QNN performance mode, options: \"burst\", \"balanced\", \"default\", \"high_performance\",\n   \"high_power_saver\", \"low_balanced\", \"extreme_power_saver\", \"low_power_saver\", \"power_saver\", \"sustained_high_performance\". Default to \"default\".\n   \"qnn_saver_path\": File path to the QNN Saver backend library. If specified, QNN Saver will be enabled and will\n   dump QNN API calls to disk for replay/debugging. QNN Saver produces incorrect model inference results and\n   may alter model/EP partitioning. Use only for debugging.\n   \"qnn_context_priority\": QNN context priority, options: \"low\", \"normal\", \"normal_high\", \"high\". Default to \"normal\".\n   \"htp_graph_finalization_optimization_mode\": Set the optimization mode for graph finalization on the HTP backend. Available options:\n     - \"0\": Default.\n     - \"1\": Faster preparation time, less optimal graph.\n     - \"2\": Longer preparation time, more optimal graph.\n     - \"3\": Longest preparation time, most likely even more optimal graph. See QNN SDK documentation for specific details.\n   \"soc_model\": The SoC model number. Refer to the QNN SDK documentation for valid values. Defaults to \"0\" (unknown).\n   \"htp_arch\": The minimum HTP architecture the driver will use to select compatible QNN operators. Available options:\n     - \"0\": Default (none).\n     - \"68\"\n     - \"69\"\n     - \"73\"\n     - \"75\"\n   \"device_id\": The ID of the device to use when setting 'htp_arch'. Defaults to \"0\" (for single device).\n\n SNPE supported keys:\n   \"runtime\": SNPE runtime engine, options: \"CPU\", \"CPU_FLOAT32\", \"GPU\", \"GPU_FLOAT32_16_HYBRID\", \"GPU_FLOAT16\",\n   \"DSP\", \"DSP_FIXED8_TF\", \"AIP_FIXED_TF\", \"AIP_FIXED8_TF\".\n   Mapping to SNPE Runtime_t definition: CPU, CPU_FLOAT32 => zdl::DlSystem::Runtime_t::CPU;\n   GPU, GPU_FLOAT32_16_HYBRID => zdl::DlSystem::Runtime_t::GPU;\n   GPU_FLOAT16 => zdl::DlSystem::Runtime_t::GPU_FLOAT16;\n   DSP, DSP_FIXED8_TF => zdl::DlSystem::Runtime_t::DSP.\n   AIP_FIXED_TF, AIP_FIXED8_TF => zdl::DlSystem::Runtime_t::AIP_FIXED_TF.\n   \"priority\": execution priority, options: \"low\", \"normal\".\n   \"buffer_type\": ITensor or user buffers, options: \"ITENSOR\", user buffer with different types - \"TF8\", \"TF16\", \"UINT8\", \"FLOAT\".\n   \"ITENSOR\" -- default, ITensor which is float only.\n   \"TF8\" -- quantized model required, \"FLOAT\" -- for both quantized or non-quantized model\n   \"enable_init_cache\": enable SNPE init caching feature, set to 1 to enabled it. Disabled by default.\n   If SNPE is not available (due to a non Snpe enabled build or its dependencies not being installed), this function will fail.\n\n XNNPACK supported keys:\n   \"intra_op_num_threads\": number of thread-pool size to use for XNNPACK execution provider.\n      default value is 0, which means to use the session thread-pool size.\n\n \\since Version 1.12."]
    pub SessionOptionsAppendExecutionProvider: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            provider_name: *const ::std::os::raw::c_char,
            provider_options_keys: *const *const ::std::os::raw::c_char,
            provider_options_values: *const *const ::std::os::raw::c_char,
            num_keys: usize,
        ) -> OrtStatusPtr,
    >,
    pub CopyKernelInfo: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            info_copy: *mut *mut OrtKernelInfo,
        ) -> OrtStatusPtr,
    >,
    pub ReleaseKernelInfo: ::std::option::Option<unsafe extern "C" fn(input: *mut OrtKernelInfo)>,
    #[doc = " \\name Ort Training\n @{\n** \\brief Gets the Training C Api struct\n*\n* Call this function to access the ::OrtTrainingApi structure that holds pointers to functions that enable\n* training with onnxruntime.\n* \\note A NULL pointer will be returned and no error message will be printed if the training api\n* is not supported with this build. A NULL pointer will be returned and an error message will be\n* printed if the provided version is unsupported, for example when using a runtime older than the\n* version created with this header file.\n*\n* \\param[in] version Must be ::ORT_API_VERSION\n* \\return The ::OrtTrainingApi struct for the version requested.\n*\n* \\since Version 1.13\n*/"]
    pub GetTrainingApi:
        ::std::option::Option<unsafe extern "C" fn(version: u32) -> *const OrtTrainingApi>,
    #[doc = " \\brief Append CANN provider to session options\n\n If CANN is not available (due to a non CANN enabled build, or if CANN is not installed on the system), this function will return failure.\n\n \\param[in] options\n \\param[in] cann_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.13."]
    pub SessionOptionsAppendExecutionProvider_CANN: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            cann_options: *const OrtCANNProviderOptions,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an OrtCANNProviderOptions\n\n \\param[out] out created ::OrtCANNProviderOptions. Must be released with OrtApi::ReleaseCANNProviderOptions\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.13."]
    pub CreateCANNProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(out: *mut *mut OrtCANNProviderOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set options in a CANN Execution Provider.\n\n \\param[in] cann_options\n \\param[in] provider_options_keys Array of UTF-8 null-terminated string for provider options keys\n \\param[in] provider_options_values Array of UTF-8 null-terminated string for provider options values\n \\param[in] num_keys Number of elements in the `provider_option_keys` and `provider_options_values` arrays\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.13."]
    pub UpdateCANNProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(
            cann_options: *mut OrtCANNProviderOptions,
            provider_options_keys: *const *const ::std::os::raw::c_char,
            provider_options_values: *const *const ::std::os::raw::c_char,
            num_keys: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get serialized CANN provider options string.\n\n \\param[in] cann_options OrtCANNProviderOptions instance\n \\param[in] allocator a ptr to an instance of OrtAllocator obtained with CreateAllocator()\n                      or GetAllocatorWithDefaultOptions(), the specified allocator will be used to allocate\n                      continuous buffers for output strings and lengths.\n \\param[out] ptr is a UTF-8 null terminated string allocated using 'allocator'.\n                 The caller is responsible for using the same allocator to free it.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.13."]
    pub GetCANNProviderOptionsAsString: ::std::option::Option<
        unsafe extern "C" fn(
            cann_options: *const OrtCANNProviderOptions,
            allocator: *mut OrtAllocator,
            ptr: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release an OrtCANNProviderOptions\n\n \\param[in] the pointer of OrtCANNProviderOptions which will been deleted\n\n \\since Version 1.13."]
    pub ReleaseCANNProviderOptions:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtCANNProviderOptions)>,
    pub MemoryInfoGetDeviceType: ::std::option::Option<
        unsafe extern "C" fn(ptr: *const OrtMemoryInfo, out: *mut OrtMemoryInfoDeviceType),
    >,
    pub UpdateEnvWithCustomLogLevel: ::std::option::Option<
        unsafe extern "C" fn(
            ort_env: *mut OrtEnv,
            log_severity_level: OrtLoggingLevel,
        ) -> OrtStatusPtr,
    >,
    pub SetGlobalIntraOpThreadAffinity: ::std::option::Option<
        unsafe extern "C" fn(
            tp_options: *mut OrtThreadingOptions,
            affinity_string: *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Register custom ops from a shared library.\n\n Loads a shared library (.dll on windows, .so on linux, etc) named 'library_name' and looks for this entry point:\n\t\tOrtStatus* RegisterCustomOps(OrtSessionOptions * options, const OrtApiBase* api);\n It then passes in the provided session options to this function along with the api base.\n\n The handle to the loaded library is automatically released by ORT when the last OrtSession that references the\n library handle is released. If no OrtSession is created, then the library handle is released when the provided\n OrtSessionOptions is released.\n\n \\param[in] options The session options.\n \\param[in] library_name The name of the shared library to load and register. Refer to OS-specific dynamic library\n                         loading utilities (e.g., LoadLibraryEx on Windows or dlopen on Linux/MacOS) for information\n                         on the format of library names and search paths.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub RegisterCustomOpsLibrary_V2: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            library_name: *const wchar_t,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Register custom ops by calling a RegisterCustomOpsFn function.\n\n Searches for registration_func_name and if found calls it.\n\n The library containing the function must either be linked against or previously loaded by the executable.\n\n If you want ONNX Runtime to load the library and manage its lifetime, use RegisterCustomOpsLibrary_V2.\n\n RegisterCustomOpsUsingFunction can be used in scenarios where it may not be possible for ONNX Runtime to load\n the library from a path. e.g. mobile platforms where the library must be linked into the app.\n\n The registration function must have the signature of RegisterCustomOpsFn:\n    OrtStatus* (*fn)(OrtSessionOptions* options, const OrtApiBase* api);\n\n See https://onnxruntime.ai/docs/reference/operators/add-custom-op.html for details on how the registration\n function should be implemented.\n\n \\param[in] options OrtSessionOptions that is passed through as the first argument in the call to the\n                    registration function.\n \\param[in] registration_func_name Name of registration function to use.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub RegisterCustomOpsUsingFunction: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            registration_func_name: *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the number of inputs from ::OrtKernelInfo.\n\n Used in the CreateKernel callback of an OrtCustomOp to query the number of inputs\n during kernel/session creation.\n\n \\param[in] info Instance of ::OrtKernelInfo.\n \\param[out] out Pointer to variable assigned with the result on success.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub KernelInfo_GetInputCount: ::std::option::Option<
        unsafe extern "C" fn(info: *const OrtKernelInfo, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the number of outputs from ::OrtKernelInfo.\n\n Used in the CreateKernel callback of an OrtCustomOp to query the number of outputs\n during kernel/session creation.\n\n \\param[in] info Instance of ::OrtKernelInfo.\n \\param[out] out Pointer to variable assigned with the result on success.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub KernelInfo_GetOutputCount: ::std::option::Option<
        unsafe extern "C" fn(info: *const OrtKernelInfo, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the name of a ::OrtKernelInfo's input.\n\n Used in the CreateKernel callback of an OrtCustomOp to query an input's name\n during kernel/session creation.\n\n If `out` is nullptr, the value of `size` is set to the size of the name\n string (including null-terminator), and a success status is returned.\n\n If the `size` parameter is greater than or equal to the name string's size,\n the value of `size` is set to the true size of the string (including null-terminator),\n the provided memory is filled with the string's contents, and a success status is returned.\n\n If the `size` parameter is less than the actual string's size and `out`\n is not nullptr, the value of `size` is set to the true size of the string\n and a failure status is returned.\n\n \\param[in] info An instance of ::OrtKernelInfo.\n \\param[in] index The index of the input name to get. Returns a failure status if out-of-bounds.\n \\param[out] out Memory location into which to write the UTF-8 null-terminated string representing the input's name.\n \\param[in,out] size Pointer to the size of the `out` buffer. See above comments for details.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub KernelInfo_GetInputName: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            index: usize,
            out: *mut ::std::os::raw::c_char,
            size: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the name of a ::OrtKernelInfo's output.\n\n Used in the CreateKernel callback of an OrtCustomOp to query an output's name\n during kernel/session creation.\n\n If `out` is nullptr, the value of `size` is set to the size of the name\n string (including null-terminator), and a success status is returned.\n\n If the `size` parameter is greater than or equal to the name string's size,\n the value of `size` is set to the true size of the string (including null-terminator),\n the provided memory is filled with the string's contents, and a success status is returned.\n\n If the `size` parameter is less than the actual string's size and `out`\n is not nullptr, the value of `size` is set to the true size of the string\n and a failure status is returned.\n\n \\param[in] info An instance of ::OrtKernelInfo.\n \\param[in] index The index of the output name to get. Returns a failure status if out-of-bounds.\n \\param[out] out Memory location into which to write the UTF-8 null-terminated string representing the output's\n                 name.\n \\param[in,out] size Pointer to the size of the `out` buffer. See above comments for details.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub KernelInfo_GetOutputName: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            index: usize,
            out: *mut ::std::os::raw::c_char,
            size: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the type information for a ::OrtKernelInfo's input.\n\n Used in the CreateKernel callback of an OrtCustomOp to query the shape and type information\n of an input during kernel/session creation.\n\n \\param[in] info An instance of ::OrtKernelInfo.\n \\param[in] index Which input to get the type information for\n \\param[out] type_info Pointer set to the resulting ::OrtTypeInfo. Must be freed with OrtApi::ReleaseTypeInfo.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub KernelInfo_GetInputTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            index: usize,
            type_info: *mut *mut OrtTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the type information for a ::OrtKernelInfo's output.\n\n Used in the CreateKernel callback of an OrtCustomOp to query the shape and type information\n of an output during kernel/session creation.\n\n \\param[in] info An instance of ::OrtKernelInfo.\n \\param[in] index Which input to get the type information for\n \\param[out] type_info Pointer set to the resulting ::OrtTypeInfo. Must be freed with OrtApi::ReleaseTypeInfo.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub KernelInfo_GetOutputTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            index: usize,
            type_info: *mut *mut OrtTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get a ::OrtValue tensor stored as an attribute in the graph node.\n\n Used in the CreateKernel callback of an OrtCustomOp to get a tensor attribute.\n\n \\param[in] info ::OrtKernelInfo instance.\n \\param[in] name UTF-8 null-terminated string representing the attribute's name.\n \\param[in] allocator Allocator used to allocate the internal tensor state.\n \\param[out] out Returns newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue,\n                 which will also free internal tensor state allocated with the provided allocator.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub KernelInfoGetAttribute_tensor: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            name: *const ::std::os::raw::c_char,
            allocator: *mut OrtAllocator,
            out: *mut *mut OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Checks if the given session configuration entry exists.\n\n The config_key formats are defined in onnxruntime_session_options_config_keys.h\n\n Can be used in a custom operator library to check for session configuration entries\n that target one or more custom operators in the library. Example: The config entry\n custom_op.myop.some_key targets a custom op named \"myop\".\n\n \\param[in] options The ::OrtSessionOptions instance.\n \\param[in] config_key A null-terminated UTF-8 string representation of the configuration key.\n \\param[out] out Pointer set to 1 if the entry exists and 0 otherwise.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub HasSessionConfigEntry: ::std::option::Option<
        unsafe extern "C" fn(
            options: *const OrtSessionOptions,
            config_key: *const ::std::os::raw::c_char,
            out: *mut ::std::os::raw::c_int,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get a session configuration value.\n\n Returns a failure status if the configuration key does not exist.\n The config_key and the format of config_value are defined in onnxruntime_session_options_config_keys.h\n\n If `config_value` is nullptr, the value of `size` is set to the true size of the string\n value (including null-terminator), and a success status is returned.\n\n If the `size` parameter is greater than or equal to the actual string value's size,\n the value of `size` is set to the true size of the string value, the provided memory\n is filled with the value's contents, and a success status is returned.\n\n If the `size` parameter is less than the actual string value's size and `config_value`\n is not nullptr, the value of `size` is set to the true size of the string value\n and a failure status is returned.\n\n Can be used in a custom operator library to get session configuration entries\n that target one or more custom operators in the library. Example: The config entry\n custom_op.myop.some_key targets a custom op named \"myop\".\n\n \\param[in] options The session options.\n \\param[in] config_key A null-terminated UTF-8 string representation of the config key.\n \\param[in] config_value Pointer to memory where the null-terminated UTF-8 string value will be stored.\n \\param[in,out] size Pointer to the size of the `config_value` buffer. See above comments for details.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.14"]
    pub GetSessionConfigEntry: ::std::option::Option<
        unsafe extern "C" fn(
            options: *const OrtSessionOptions,
            config_key: *const ::std::os::raw::c_char,
            config_value: *mut ::std::os::raw::c_char,
            size: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Append dnnl provider to session options\n\n If oneDNN is not available, this function will return failure.\n\n \\param[in] options\n \\param[in] dnnl_options\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.15."]
    pub SessionOptionsAppendExecutionProvider_Dnnl: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            dnnl_options: *const OrtDnnlProviderOptions,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Create an OrtDnnlProviderOptions\n\n \\param[out] out Newly created ::OrtDnnlProviderOptions. Must be released with OrtApi::ReleaseDnnlProviderOptions\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.15."]
    pub CreateDnnlProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(out: *mut *mut OrtDnnlProviderOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set options in a oneDNN Execution Provider.\n\n Key should be in null terminated string format of the member of ::OrtDnnlProviderOptions\n and value should be its related range.\n\n For example, key=\"use_arena\" and value=\"1\"\n\n \\param[in] dnnl_options\n \\param[in] provider_options_keys Array of UTF-8 null-terminated string for provider options keys\n \\param[in] provider_options_values Array of UTF-8 null-terminated string for provider options values\n \\param[in] num_keys Number of elements in the `provider_option_keys` and `provider_options_values` arrays\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.15."]
    pub UpdateDnnlProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(
            dnnl_options: *mut OrtDnnlProviderOptions,
            provider_options_keys: *const *const ::std::os::raw::c_char,
            provider_options_values: *const *const ::std::os::raw::c_char,
            num_keys: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Get serialized oneDNN provider options string.\n\n For example, \"use_arena=1;......\"\n\n \\param dnnl_options - OrtDnnlProviderOptions instance\n \\param allocator - a ptr to an instance of OrtAllocator obtained with CreateAllocator() or GetAllocatorWithDefaultOptions()\n                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.\n \\param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.15."]
    pub GetDnnlProviderOptionsAsString: ::std::option::Option<
        unsafe extern "C" fn(
            dnnl_options: *const OrtDnnlProviderOptions,
            allocator: *mut OrtAllocator,
            ptr: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release an ::OrtDnnlProviderOptions\n\n \\since Version 1.15."]
    pub ReleaseDnnlProviderOptions:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtDnnlProviderOptions)>,
    #[doc = " \\brief Get the graph node name from ::OrtKernelInfo.\n\n If `out` is nullptr, the value of `size` is set to the size of the name\n string (including null-terminator), and a success status is returned.\n\n If the `size` parameter is greater than or equal to the name string's size,\n the value of `size` is set to the true size of the string (including null-terminator),\n the provided memory is filled with the string's contents, and a success status is returned.\n\n If the `size` parameter is less than the actual string's size and `out`\n is not nullptr, the value of `size` is set to the true size of the string\n and a failure status is returned.\n\n Can be used in a custom operator's CreateKernel callback to get the name of the operator's node name in the graph.\n\n \\param[in] info An instance of ::OrtKernelInfo.\n \\param[out] out Memory location into which to write the UTF-8 null-terminated string representing the name.\n \\param[in,out] size Pointer to the size of the `out` buffer. See above comments for details.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.15"]
    pub KernelInfo_GetNodeName: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            out: *mut ::std::os::raw::c_char,
            size: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the session logger from ::OrtKernelInfo.\n\n Used in the CreateKernel callback of an OrtCustomOp to get a logger that can be used to log\n messages.\n\n \\param[in] info An instance of ::OrtKernelInfo.\n \\param[out] logger Pointer set to the session's ::OrtLogger. Owned by ONNX Runtime, so do not free.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.15"]
    pub KernelInfo_GetLogger: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            logger: *mut *const OrtLogger,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the runtime logger from ::OrtKernelContext.\n\n Used in the KernelCompute callback of an OrtCustomOp to get a logger that can be used to log\n messages during inference.\n\n \\param[in] context An instance of ::OrtKernelContext.\n \\param[out] logger Pointer set to the kernel context's ::OrtLogger. Owned by ONNX Runtime, so do not free.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.15"]
    pub KernelContext_GetLogger: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtKernelContext,
            logger: *mut *const OrtLogger,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Logs a message at the given severity level using the provided ::OrtLogger.\n\n Only messages with a severity level equal or greater than the ::OrtLogger's logging severity level\n are logged. Use OrtApi::Logger_GetLoggingSeverityLevel to get the ::OrtLogger's logging severity\n level.\n\n Can be used in custom operators to log messages with the logger retrieved via OrtApi::KernelInfo_GetLogger.\n\n \\param[in] logger The ::OrtLogger instance.\n \\param[in] log_severity_level The message's severity level.\n \\param[in] message The message to log.\n \\param[in] file_path The filepath of the file in which the message is logged. Usually the value of ORT_FILE.\n \\param[in] line_number The file line number in which the message is logged. Usually the value of __LINE__.\n \\param[in] func_name The name of the function in which the message is logged. Usually the value of __FUNCTION__.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.15"]
    pub Logger_LogMessage: ::std::option::Option<
        unsafe extern "C" fn(
            logger: *const OrtLogger,
            log_severity_level: OrtLoggingLevel,
            message: *const ::std::os::raw::c_char,
            file_path: *const wchar_t,
            line_number: ::std::os::raw::c_int,
            func_name: *const ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get the logging severity level of the ::OrtLogger.\n\n Can be used in a custom operator to get the logging serverity level of the ::OrtLogger associated with\n the ::OrtKernelInfo.\n\n \\param[in] logger The ::OrtLogger instance.\n \\param[out] out Pointer to variable assigned with the logging severity level on success.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n \\since Version 1.15"]
    pub Logger_GetLoggingSeverityLevel: ::std::option::Option<
        unsafe extern "C" fn(logger: *const OrtLogger, out: *mut OrtLoggingLevel) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get a ::OrtValue tensor stored as a constant initializer in the graph node.\n\n Used in the CreateKernel callback of an OrtCustomOp to get a tensor value.\n\n \\param[in] info ::OrtKernelInfo instance.\n \\param[in] index The node index.\n \\param[out] is_constant Is it a constant node input or not.\n \\param[out] out The OrtValue tensor value.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.15."]
    pub KernelInfoGetConstantInput_tensor: ::std::option::Option<
        unsafe extern "C" fn(
            info: *const OrtKernelInfo,
            index: usize,
            is_constant: *mut ::std::os::raw::c_int,
            out: *mut *const OrtValue,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get Optional Type information from an ::OrtTypeInfo\n\n This augments ::OrtTypeInfo to return an ::OrtOptionalTypeInfo when the type is optional.\n The OrtOptionalTypeInfo also has a nested ::OrtTypeInfo that describes the type of the optional value.\n ::OrtOptionalTypeInfo type can only appear within model metadata to describe inputs/outputs.\n The actual OrtValues that are supplied in place of optional type inputs should contain\n specific type that is described by ::OrtOptionalTypeInfo.\n\n So the picture: ::OrtTypeInfo -> ::OrtOptionalTypeInfo -> ::OrtTypeInfo (describes the type that can be supplied\n in place of the optional type when creating the actual ::OrtValue).\n\n \\param[in] type_info\n \\param[out] out A pointer to the ::OrtOptionalTypeInfo. Do not free this value,\n                 it is owned by OrtTypeInfo instance. When the type_info does not represent\n                 optional type, nullptr is returned in out.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.15."]
    pub CastTypeInfoToOptionalTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            type_info: *const OrtTypeInfo,
            out: *mut *const OrtOptionalTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get OrtTypeInfo for the allowed contained type from an ::OrtOptionalTypeInfo.\n\n This augments ::OrtOptionalTypeInfo to return an ::OrtTypeInfo for the contained type.\n The OrtOptionalTypeInfo has a nested ::OrtTypeInfo that describes the type of the optional value.\n ::OrtOptionalTypeInfo type can only appear within model metadata to describe inputs/outputs.\n The actual OrtValues that are supplied in place of optional type inputs should contain\n specific type that is described by the returned ::OrtTypeInfo.\n\n \\param[in] optional_type_info\n \\param[out] out A pointer to the ::OrtTypeInfo for what the optional value could be.\n it is owned by OrtOptionalTypeInfo instance.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.15."]
    pub GetOptionalContainedTypeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            optional_type_info: *const OrtOptionalTypeInfo,
            out: *mut *mut OrtTypeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set a single string in a string tensor\n  Do not zero terminate the string data.\n\n \\param[in] value A string tensor\n \\param[in] index - flat index of the element\n \\param[in] length_in_bytes length of the buffer in utf-8 bytes (without the null terminator)\n \\param[inout] buffer - address of return value\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub GetResizedStringTensorElementBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut OrtValue,
            index: usize,
            length_in_bytes: usize,
            buffer: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Get Allocator from KernelContext for a specific memoryInfo. Please use C API ReleaseAllocator to release out object\n\n \\param[in] context OrtKernelContext instance\n \\param[in] mem_info OrtMemoryInfo instance\n \\param[out] out A pointer to OrtAllocator.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.15."]
    pub KernelContext_GetAllocator: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtKernelContext,
            mem_info: *const OrtMemoryInfo,
            out: *mut *mut OrtAllocator,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Returns a null terminated string of the build info including git info and cxx flags\n\n \\return UTF-8 encoded version string. Do not deallocate the returned buffer.\n\n \\since Version 1.15."]
    pub GetBuildInfoString:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    #[doc = " \\brief Create an OrtROCMProviderOptions\n\n \\param[out] out Newly created ::OrtROCMProviderOptions. Must be released with OrtApi::ReleaseROCMProviderOptions\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.16."]
    pub CreateROCMProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(out: *mut *mut OrtROCMProviderOptions) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set options in a ROCm Execution Provider.\n\n Please refer to https://onnxruntime.ai/docs/execution-providers/ROCm-ExecutionProvider.html\n to know the available keys and values. Key should be in null terminated string format of the member of\n ::OrtROCMProviderOptions and value should be its related range.\n\n For example, key=\"device_id\" and value=\"0\"\n\n \\param[in] rocm_options\n \\param[in] provider_options_keys Array of UTF-8 null-terminated string for provider options keys\n \\param[in] provider_options_values Array of UTF-8 null-terminated string for provider options values\n \\param[in] num_keys Number of elements in the `provider_option_keys` and `provider_options_values` arrays\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.16."]
    pub UpdateROCMProviderOptions: ::std::option::Option<
        unsafe extern "C" fn(
            rocm_options: *mut OrtROCMProviderOptions,
            provider_options_keys: *const *const ::std::os::raw::c_char,
            provider_options_values: *const *const ::std::os::raw::c_char,
            num_keys: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Get serialized ROCm provider options string.\n\n For example, \"device_id=0;arena_extend_strategy=0;......\"\n\n \\param rocm_options - OrtROCMProviderOptions instance\n \\param allocator - a ptr to an instance of OrtAllocator obtained with CreateAllocator() or GetAllocatorWithDefaultOptions()\n                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.\n \\param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.16."]
    pub GetROCMProviderOptionsAsString: ::std::option::Option<
        unsafe extern "C" fn(
            rocm_options: *const OrtROCMProviderOptions,
            allocator: *mut OrtAllocator,
            ptr: *mut *mut ::std::os::raw::c_char,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Release an ::OrtROCMProviderOptions\n\n \\note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does\n\n \\since Version 1.16."]
    pub ReleaseROCMProviderOptions:
        ::std::option::Option<unsafe extern "C" fn(input: *mut OrtROCMProviderOptions)>,
    #[doc = " \\brief Create an allocator with specific type and register it with the ::OrtEnv\n  This API enhance CreateAndRegisterAllocator that it can create an allocator with specific type, not just CPU allocator\n  Enables sharing the allocator between multiple sessions that use the same env instance.\n  Lifetime of the created allocator will be valid for the duration of the environment.\n  Returns an error if an allocator with the same ::OrtMemoryInfo is already registered.\n  \\param[in] env OrtEnv instance\n  \\param[in] provider_type ExecutionProvider type\n  \\param[in] mem_info OrtMemoryInfo instance\n  \\param[in] arena_cfg Arena configuration\n  \\param[in] provider_options_keys key of the provider options map\n  \\param[in] provider_options_values value of the provider options map\n  \\param[in] num_keys Length of the provider options map"]
    pub CreateAndRegisterAllocatorV2: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut OrtEnv,
            provider_type: *const ::std::os::raw::c_char,
            mem_info: *const OrtMemoryInfo,
            arena_cfg: *const OrtArenaCfg,
            provider_options_keys: *const *const ::std::os::raw::c_char,
            provider_options_values: *const *const ::std::os::raw::c_char,
            num_keys: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Run the model asynchronously in a thread owned by intra op thread pool\n\n \\param[in] session\n \\param[in] run_options If nullptr, will use a default ::OrtRunOptions\n \\param[in] input_names Array of null terminated UTF8 encoded strings of the input names\n \\param[in] input Array of ::OrtValue%s of the input values\n \\param[in] input_len Number of elements in the input_names and inputs arrays\n \\param[in] output_names Array of null terminated UTF8 encoded strings of the output names\n \\param[in] output_names_len Number of elements in the output_names and outputs array\n \\param[out] output OrtValue* array of size output_names_len.\n             On calling RunAsync, output[i] could either be a null or a pointer to a preallocated OrtValue.\n             Later, the output array will be passed to run_async_callback with all null(s) filled with valid\n             OrtValue pointer(s) allocated by onnxruntime.\n             NOTE: it is customer's duty to finally release the output array and each of its member,\n             regardless of whether the member (OrtValue*) is allocated by onnxruntime or preallocated by the customer.\n \\param[in] run_async_callback Callback function on model run completion\n \\param[in] user_data User data that pass back to run_async_callback"]
    pub RunAsync: ::std::option::Option<
        unsafe extern "C" fn(
            session: *mut OrtSession,
            run_options: *const OrtRunOptions,
            input_names: *const *const ::std::os::raw::c_char,
            input: *const *const OrtValue,
            input_len: usize,
            output_names: *const *const ::std::os::raw::c_char,
            output_names_len: usize,
            output: *mut *mut OrtValue,
            run_async_callback: RunAsyncCallbackFn,
            user_data: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Update TensorRT EP provider option where its data type is pointer, for example 'user_compute_stream'.\n If the data type of the provider option can be represented by string please use UpdateTensorRTProviderOptions.\n\n Note: It's caller's responsibility to properly manage the lifetime of the instance pointed by this pointer.\n\n \\param tensorrt_options - OrtTensorRTProviderOptionsV2 instance\n \\param key - Name of the provider option\n \\param value - A pointer to the instance that will be assigned to this provider option\n\n \\since Version 1.16."]
    pub UpdateTensorRTProviderOptionsWithValue: ::std::option::Option<
        unsafe extern "C" fn(
            tensorrt_options: *mut OrtTensorRTProviderOptionsV2,
            key: *const ::std::os::raw::c_char,
            value: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Get TensorRT EP provider option where its data type is pointer.\n If the data type of the provider option can be represented by string please use GetTensorRTProviderOptionsAsString.\n\n \\param tensorrt_options - OrtTensorRTProviderOptionsV2 instance\n \\param key - Name of the provider option\n \\param ptr - A pointer to the instance that is kept by the provider option\n\n \\since Version 1.16."]
    pub GetTensorRTProviderOptionsByName: ::std::option::Option<
        unsafe extern "C" fn(
            tensorrt_options: *const OrtTensorRTProviderOptionsV2,
            key: *const ::std::os::raw::c_char,
            ptr: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Update CUDA EP provider option where its data type is pointer, for example 'user_compute_stream'.\n If the data type of the provider option can be represented by string please use UpdateCUDAProviderOptions.\n\n Note: It's caller's responsibility to properly manage the lifetime of the instance pointed by this pointer.\n\n \\param cuda_options - OrtCUDAProviderOptionsV2 instance\n \\param key - Name of the provider option\n \\param value - A pointer to the instance that will be assigned to this provider option\n\n \\since Version 1.16."]
    pub UpdateCUDAProviderOptionsWithValue: ::std::option::Option<
        unsafe extern "C" fn(
            cuda_options: *mut OrtCUDAProviderOptionsV2,
            key: *const ::std::os::raw::c_char,
            value: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Get CUDA EP provider option where its data type is pointer.\n If the data type of the provider option can be represented by string please use GetCUDAProviderOptionsAsString.\n\n \\param cuda_options - OrtCUDAProviderOptionsV2 instance\n \\param key - Name of the provider option\n \\param ptr - A pointer to the instance that is kept by the provider option\n\n \\since Version 1.16."]
    pub GetCUDAProviderOptionsByName: ::std::option::Option<
        unsafe extern "C" fn(
            cuda_options: *const OrtCUDAProviderOptionsV2,
            key: *const ::std::os::raw::c_char,
            ptr: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Get a EP resource.\n E.g. a cuda stream or a cublas handle\n\n \\param context - Kernel context\n \\param resouce_version - Version of the resource\n \\param resource_id - Type of resource\n \\param resource - A pointer to returned resource\n\n \\since Version 1.16."]
    pub KernelContext_GetResource: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtKernelContext,
            resouce_version: ::std::os::raw::c_int,
            resource_id: ::std::os::raw::c_int,
            resource: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set user logging function\n\n  By default the logger created by the CreateEnv* functions is used to create the session logger as well.\n  This function allows a user to override this default session logger with a logger of their own choosing. This way\n  the user doesn't have to create a separate environment with a custom logger. This addresses the problem when\n  the user already created an env but now wants to use a different logger for a specific session (for debugging or\n  other reasons).\n\n \\param[in] options\n \\param[in] user_logging_function A pointer to a logging function.\n \\param[in] user_logging_param A pointer to arbitrary data passed as the ::OrtLoggingFunction `param` parameter to\n                         `user_logging_function`. This parameter is optional.\n\n \\snippet{doc} snippets.dox OrtStatus Return Value\n\n \\since Version 1.17."]
    pub SetUserLoggingFunction: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            user_logging_function: OrtLoggingFunction,
            user_logging_param: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Get number of input from OrtShapeInferContext\n\n \\param[in] context\n \\param[out] out The number of inputs\n\n \\since Version 1.17."]
    pub ShapeInferContext_GetInputCount: ::std::option::Option<
        unsafe extern "C" fn(context: *const OrtShapeInferContext, out: *mut usize) -> OrtStatusPtr,
    >,
    #[doc = " Get type and shape info of an input\n\n \\param[in] context\n \\param[in] index The index of the input\n \\param[out] info Type shape info of the input\n\n \\since Version 1.17."]
    pub ShapeInferContext_GetInputTypeShape: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtShapeInferContext,
            index: usize,
            info: *mut *mut OrtTensorTypeAndShapeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Get attribute from OrtShapeInferContext. Note that OrtShapeInferContext is a per-node context, one could only read attribute from current node.\n\n \\param[in] context\n \\param[in] attr_name Name of the attribute\n \\param[out] attr Handle of the attribute fetched\n\n \\since Version 1.17."]
    pub ShapeInferContext_GetAttribute: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtShapeInferContext,
            attr_name: *const ::std::os::raw::c_char,
            attr: *mut *const OrtOpAttr,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Set type and shape info of an ouput\n\n \\param[in] context\n \\param[in] index The index of the ouput\n \\param[out] info Type shape info of the output\n\n \\since Version 1.17."]
    pub ShapeInferContext_SetOutputTypeShape: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtShapeInferContext,
            index: usize,
            info: *const OrtTensorTypeAndShapeInfo,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Set symbolic shape to type shape info\n\n \\param[in] info Type shape info\n \\param[in] dim_params Symbolic strings\n \\param[in] dim_params_length Number of strings\n\n \\since Version 1.17."]
    pub SetSymbolicDimensions: ::std::option::Option<
        unsafe extern "C" fn(
            info: *mut OrtTensorTypeAndShapeInfo,
            dim_params: *mut *const ::std::os::raw::c_char,
            dim_params_length: usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " Read contents of an attribute to data\n\n \\param[in] op_attr\n \\param[in] type Attribute type\n \\param[out] data Memory address to save raw content of the attribute\n \\param[in] len Number of bytes allowed to store in data\n \\param[out] out Number of bytes required to save the data when the call failed, or the real number of bytes saved to data on success\n\n \\since Version 1.17."]
    pub ReadOpAttr: ::std::option::Option<
        unsafe extern "C" fn(
            op_attr: *const OrtOpAttr,
            type_: OrtOpAttrType,
            data: *mut ::std::os::raw::c_void,
            len: usize,
            out: *mut usize,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Set whether to use deterministic compute.\n\n Default is false. If set to true, this will enable deterministic compute for GPU kernels where possible.\n Note that this most likely will have a performance cost.\n\n \\param[in] options\n \\param[in] value\n\n \\since Version 1.17."]
    pub SetDeterministicCompute: ::std::option::Option<
        unsafe extern "C" fn(options: *mut OrtSessionOptions, value: bool) -> OrtStatusPtr,
    >,
    #[doc = " Run fn in parallel\n\n \\param[in] context\n \\param[in] fn Function accepting usr_data and an integer as iterator\n \\param[in] total The number of times fn is to be invoked\n \\param[in] num_batch Number of batches by which the \"total\" is to be divided in maximum. When zero, there is no limit\n \\param[in] usr_data User data to be passed back to fn\n\n \\since Version 1.17."]
    pub KernelContext_ParallelFor: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const OrtKernelContext,
            fn_: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: usize),
            >,
            total: usize,
            num_batch: usize,
            usr_data: *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    #[doc = " \\brief Append OpenVINO execution provider to the session options\n\n If OpenVINO is not available (due to a non OpenVINO enabled build, or if OpenVINO is not installed on the system), this function will fail.\n\n \\param[in] options\n \\param[in] provider_options_keys\n \\param[in] provider_options_values\n \\param[in] num_keys\n\n \\snippet{doc} snippets.dox OrtStatus Return Value"]
    pub SessionOptionsAppendExecutionProvider_OpenVINO_V2: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut OrtSessionOptions,
            provider_options_keys: *const *const ::std::os::raw::c_char,
            provider_options_values: *const *const ::std::os::raw::c_char,
            num_keys: usize,
        ) -> OrtStatusPtr,
    >,
}
#[test]
fn bindgen_test_layout_OrtApi() {
    const UNINIT: ::std::mem::MaybeUninit<OrtApi> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtApi>(),
        2208usize,
        concat!("Size of: ", stringify!(OrtApi))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtApi>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtApi))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateStatus) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetErrorCode) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetErrorCode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetErrorMessage) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetErrorMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateEnv) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateEnv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateEnvWithCustomLogger) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateEnvWithCustomLogger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableTelemetryEvents) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(EnableTelemetryEvents))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableTelemetryEvents) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(DisableTelemetryEvents))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateSession) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateSession))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateSessionFromArray) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateSessionFromArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Run) as usize - ptr as usize },
        72usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(Run))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateSessionOptions) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateSessionOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetOptimizedModelFilePath) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetOptimizedModelFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CloneSessionOptions) as usize - ptr as usize },
        96usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CloneSessionOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetSessionExecutionMode) as usize - ptr as usize },
        104usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetSessionExecutionMode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableProfiling) as usize - ptr as usize },
        112usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(EnableProfiling))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableProfiling) as usize - ptr as usize },
        120usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(DisableProfiling))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableMemPattern) as usize - ptr as usize },
        128usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(EnableMemPattern))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableMemPattern) as usize - ptr as usize },
        136usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(DisableMemPattern))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableCpuMemArena) as usize - ptr as usize },
        144usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(EnableCpuMemArena))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisableCpuMemArena) as usize - ptr as usize },
        152usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(DisableCpuMemArena))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetSessionLogId) as usize - ptr as usize },
        160usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetSessionLogId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetSessionLogVerbosityLevel) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetSessionLogVerbosityLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetSessionLogSeverityLevel) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetSessionLogSeverityLevel)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SetSessionGraphOptimizationLevel) as usize - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetSessionGraphOptimizationLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetIntraOpNumThreads) as usize - ptr as usize },
        192usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetIntraOpNumThreads))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetInterOpNumThreads) as usize - ptr as usize },
        200usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetInterOpNumThreads))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateCustomOpDomain) as usize - ptr as usize },
        208usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateCustomOpDomain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomOpDomain_Add) as usize - ptr as usize },
        216usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CustomOpDomain_Add))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddCustomOpDomain) as usize - ptr as usize },
        224usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(AddCustomOpDomain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegisterCustomOpsLibrary) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(RegisterCustomOpsLibrary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionGetInputCount) as usize - ptr as usize },
        240usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SessionGetInputCount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionGetOutputCount) as usize - ptr as usize },
        248usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SessionGetOutputCount))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionGetOverridableInitializerCount) as usize
                - ptr as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionGetOverridableInitializerCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionGetInputTypeInfo) as usize - ptr as usize },
        264usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SessionGetInputTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionGetOutputTypeInfo) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionGetOutputTypeInfo)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionGetOverridableInitializerTypeInfo) as usize
                - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionGetOverridableInitializerTypeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionGetInputName) as usize - ptr as usize },
        288usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SessionGetInputName))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionGetOutputName) as usize - ptr as usize },
        296usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SessionGetOutputName))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionGetOverridableInitializerName) as usize
                - ptr as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionGetOverridableInitializerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateRunOptions) as usize - ptr as usize },
        312usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateRunOptions))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).RunOptionsSetRunLogVerbosityLevel) as usize - ptr as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(RunOptionsSetRunLogVerbosityLevel)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).RunOptionsSetRunLogSeverityLevel) as usize - ptr as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(RunOptionsSetRunLogSeverityLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RunOptionsSetRunTag) as usize - ptr as usize },
        336usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(RunOptionsSetRunTag))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).RunOptionsGetRunLogVerbosityLevel) as usize - ptr as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(RunOptionsGetRunLogVerbosityLevel)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).RunOptionsGetRunLogSeverityLevel) as usize - ptr as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(RunOptionsGetRunLogSeverityLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RunOptionsGetRunTag) as usize - ptr as usize },
        360usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(RunOptionsGetRunTag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RunOptionsSetTerminate) as usize - ptr as usize },
        368usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(RunOptionsSetTerminate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RunOptionsUnsetTerminate) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(RunOptionsUnsetTerminate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateTensorAsOrtValue) as usize - ptr as usize },
        384usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateTensorAsOrtValue))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateTensorWithDataAsOrtValue) as usize - ptr as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateTensorWithDataAsOrtValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsTensor) as usize - ptr as usize },
        400usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(IsTensor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetTensorMutableData) as usize - ptr as usize },
        408usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetTensorMutableData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FillStringTensor) as usize - ptr as usize },
        416usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(FillStringTensor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetStringTensorDataLength) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetStringTensorDataLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetStringTensorContent) as usize - ptr as usize },
        432usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetStringTensorContent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CastTypeInfoToTensorInfo) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CastTypeInfoToTensorInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetOnnxTypeFromTypeInfo) as usize - ptr as usize },
        448usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetOnnxTypeFromTypeInfo))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateTensorTypeAndShapeInfo) as usize - ptr as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateTensorTypeAndShapeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetTensorElementType) as usize - ptr as usize },
        464usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetTensorElementType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetDimensions) as usize - ptr as usize },
        472usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetDimensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetTensorElementType) as usize - ptr as usize },
        480usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetTensorElementType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetDimensionsCount) as usize - ptr as usize },
        488usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetDimensionsCount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetDimensions) as usize - ptr as usize },
        496usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetDimensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSymbolicDimensions) as usize - ptr as usize },
        504usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetSymbolicDimensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetTensorShapeElementCount) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetTensorShapeElementCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetTensorTypeAndShape) as usize - ptr as usize },
        520usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetTensorTypeAndShape))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetTypeInfo) as usize - ptr as usize },
        528usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetValueType) as usize - ptr as usize },
        536usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetValueType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateMemoryInfo) as usize - ptr as usize },
        544usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateMemoryInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateCpuMemoryInfo) as usize - ptr as usize },
        552usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateCpuMemoryInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompareMemoryInfo) as usize - ptr as usize },
        560usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CompareMemoryInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemoryInfoGetName) as usize - ptr as usize },
        568usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(MemoryInfoGetName))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemoryInfoGetId) as usize - ptr as usize },
        576usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(MemoryInfoGetId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemoryInfoGetMemType) as usize - ptr as usize },
        584usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(MemoryInfoGetMemType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemoryInfoGetType) as usize - ptr as usize },
        592usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(MemoryInfoGetType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocatorAlloc) as usize - ptr as usize },
        600usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(AllocatorAlloc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocatorFree) as usize - ptr as usize },
        608usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(AllocatorFree))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocatorGetInfo) as usize - ptr as usize },
        616usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(AllocatorGetInfo))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetAllocatorWithDefaultOptions) as usize - ptr as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetAllocatorWithDefaultOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddFreeDimensionOverride) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(AddFreeDimensionOverride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetValue) as usize - ptr as usize },
        640usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetValueCount) as usize - ptr as usize },
        648usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetValueCount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateValue) as usize - ptr as usize },
        656usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateOpaqueValue) as usize - ptr as usize },
        664usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateOpaqueValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetOpaqueValue) as usize - ptr as usize },
        672usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetOpaqueValue))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelInfoGetAttribute_float) as usize - ptr as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfoGetAttribute_float)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelInfoGetAttribute_int64) as usize - ptr as usize
        },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfoGetAttribute_int64)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelInfoGetAttribute_string) as usize - ptr as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfoGetAttribute_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelContext_GetInputCount) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelContext_GetInputCount)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelContext_GetOutputCount) as usize - ptr as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelContext_GetOutputCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelContext_GetInput) as usize - ptr as usize },
        720usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(KernelContext_GetInput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelContext_GetOutput) as usize - ptr as usize },
        728usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(KernelContext_GetOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseEnv) as usize - ptr as usize },
        736usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseEnv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseStatus) as usize - ptr as usize },
        744usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseMemoryInfo) as usize - ptr as usize },
        752usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseMemoryInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseSession) as usize - ptr as usize },
        760usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseSession))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseValue) as usize - ptr as usize },
        768usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseRunOptions) as usize - ptr as usize },
        776usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseRunOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseTypeInfo) as usize - ptr as usize },
        784usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseTypeInfo))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ReleaseTensorTypeAndShapeInfo) as usize - ptr as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ReleaseTensorTypeAndShapeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseSessionOptions) as usize - ptr as usize },
        800usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseSessionOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseCustomOpDomain) as usize - ptr as usize },
        808usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseCustomOpDomain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetDenotationFromTypeInfo) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetDenotationFromTypeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CastTypeInfoToMapTypeInfo) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CastTypeInfoToMapTypeInfo)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CastTypeInfoToSequenceTypeInfo) as usize - ptr as usize
        },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CastTypeInfoToSequenceTypeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetMapKeyType) as usize - ptr as usize },
        840usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetMapKeyType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetMapValueType) as usize - ptr as usize },
        848usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetMapValueType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSequenceElementType) as usize - ptr as usize },
        856usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetSequenceElementType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseMapTypeInfo) as usize - ptr as usize },
        864usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseMapTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseSequenceTypeInfo) as usize - ptr as usize },
        872usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseSequenceTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionEndProfiling) as usize - ptr as usize },
        880usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SessionEndProfiling))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionGetModelMetadata) as usize - ptr as usize },
        888usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SessionGetModelMetadata))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ModelMetadataGetProducerName) as usize - ptr as usize
        },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ModelMetadataGetProducerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModelMetadataGetGraphName) as usize - ptr as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ModelMetadataGetGraphName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModelMetadataGetDomain) as usize - ptr as usize },
        912usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ModelMetadataGetDomain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModelMetadataGetDescription) as usize - ptr as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ModelMetadataGetDescription)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ModelMetadataLookupCustomMetadataMap) as usize
                - ptr as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ModelMetadataLookupCustomMetadataMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModelMetadataGetVersion) as usize - ptr as usize },
        936usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ModelMetadataGetVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseModelMetadata) as usize - ptr as usize },
        944usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseModelMetadata))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateEnvWithGlobalThreadPools) as usize - ptr as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateEnvWithGlobalThreadPools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisablePerSessionThreads) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(DisablePerSessionThreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateThreadingOptions) as usize - ptr as usize },
        968usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateThreadingOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseThreadingOptions) as usize - ptr as usize },
        976usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseThreadingOptions))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ModelMetadataGetCustomMetadataMapKeys) as usize
                - ptr as usize
        },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ModelMetadataGetCustomMetadataMapKeys)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).AddFreeDimensionOverrideByName) as usize - ptr as usize
        },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(AddFreeDimensionOverrideByName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetAvailableProviders) as usize - ptr as usize },
        1000usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetAvailableProviders))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseAvailableProviders) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ReleaseAvailableProviders)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetStringTensorElementLength) as usize - ptr as usize
        },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetStringTensorElementLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetStringTensorElement) as usize - ptr as usize },
        1024usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetStringTensorElement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FillStringTensorElement) as usize - ptr as usize },
        1032usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(FillStringTensorElement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddSessionConfigEntry) as usize - ptr as usize },
        1040usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(AddSessionConfigEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateAllocator) as usize - ptr as usize },
        1048usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseAllocator) as usize - ptr as usize },
        1056usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RunWithBinding) as usize - ptr as usize },
        1064usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(RunWithBinding))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateIoBinding) as usize - ptr as usize },
        1072usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateIoBinding))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseIoBinding) as usize - ptr as usize },
        1080usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseIoBinding))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BindInput) as usize - ptr as usize },
        1088usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(BindInput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BindOutput) as usize - ptr as usize },
        1096usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(BindOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BindOutputToDevice) as usize - ptr as usize },
        1104usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(BindOutputToDevice))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetBoundOutputNames) as usize - ptr as usize },
        1112usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetBoundOutputNames))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetBoundOutputValues) as usize - ptr as usize },
        1120usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetBoundOutputValues))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClearBoundInputs) as usize - ptr as usize },
        1128usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ClearBoundInputs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClearBoundOutputs) as usize - ptr as usize },
        1136usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ClearBoundOutputs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TensorAt) as usize - ptr as usize },
        1144usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(TensorAt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateAndRegisterAllocator) as usize - ptr as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateAndRegisterAllocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetLanguageProjection) as usize - ptr as usize },
        1160usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetLanguageProjection))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionGetProfilingStartTimeNs) as usize - ptr as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionGetProfilingStartTimeNs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetGlobalIntraOpNumThreads) as usize - ptr as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetGlobalIntraOpNumThreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetGlobalInterOpNumThreads) as usize - ptr as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetGlobalInterOpNumThreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetGlobalSpinControl) as usize - ptr as usize },
        1192usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetGlobalSpinControl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddInitializer) as usize - ptr as usize },
        1200usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(AddInitializer))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateEnvWithCustomLoggerAndGlobalThreadPools) as usize
                - ptr as usize
        },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateEnvWithCustomLoggerAndGlobalThreadPools)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_CUDA) as usize
                - ptr as usize
        },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_CUDA)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_ROCM) as usize
                - ptr as usize
        },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_ROCM)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_OpenVINO) as usize
                - ptr as usize
        },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_OpenVINO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetGlobalDenormalAsZero) as usize - ptr as usize },
        1240usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetGlobalDenormalAsZero))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateArenaCfg) as usize - ptr as usize },
        1248usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateArenaCfg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseArenaCfg) as usize - ptr as usize },
        1256usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseArenaCfg))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ModelMetadataGetGraphDescription) as usize - ptr as usize
        },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ModelMetadataGetGraphDescription)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_TensorRT) as usize
                - ptr as usize
        },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_TensorRT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetCurrentGpuDeviceId) as usize - ptr as usize },
        1280usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetCurrentGpuDeviceId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetCurrentGpuDeviceId) as usize - ptr as usize },
        1288usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetCurrentGpuDeviceId))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelInfoGetAttributeArray_float) as usize - ptr as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfoGetAttributeArray_float)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelInfoGetAttributeArray_int64) as usize - ptr as usize
        },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfoGetAttributeArray_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateArenaCfgV2) as usize - ptr as usize },
        1312usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateArenaCfgV2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddRunConfigEntry) as usize - ptr as usize },
        1320usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(AddRunConfigEntry))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreatePrepackedWeightsContainer) as usize - ptr as usize
        },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreatePrepackedWeightsContainer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ReleasePrepackedWeightsContainer) as usize - ptr as usize
        },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ReleasePrepackedWeightsContainer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateSessionWithPrepackedWeightsContainer) as usize
                - ptr as usize
        },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateSessionWithPrepackedWeightsContainer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateSessionFromArrayWithPrepackedWeightsContainer)
                as usize
                - ptr as usize
        },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateSessionFromArrayWithPrepackedWeightsContainer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_TensorRT_V2) as usize
                - ptr as usize
        },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_TensorRT_V2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateTensorRTProviderOptions) as usize - ptr as usize
        },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateTensorRTProviderOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).UpdateTensorRTProviderOptions) as usize - ptr as usize
        },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(UpdateTensorRTProviderOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetTensorRTProviderOptionsAsString) as usize - ptr as usize
        },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetTensorRTProviderOptionsAsString)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ReleaseTensorRTProviderOptions) as usize - ptr as usize
        },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ReleaseTensorRTProviderOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableOrtCustomOps) as usize - ptr as usize },
        1400usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(EnableOrtCustomOps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegisterAllocator) as usize - ptr as usize },
        1408usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(RegisterAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnregisterAllocator) as usize - ptr as usize },
        1416usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(UnregisterAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsSparseTensor) as usize - ptr as usize },
        1424usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(IsSparseTensor))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateSparseTensorAsOrtValue) as usize - ptr as usize
        },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateSparseTensorAsOrtValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FillSparseTensorCoo) as usize - ptr as usize },
        1440usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(FillSparseTensorCoo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FillSparseTensorCsr) as usize - ptr as usize },
        1448usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(FillSparseTensorCsr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FillSparseTensorBlockSparse) as usize - ptr as usize },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(FillSparseTensorBlockSparse)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateSparseTensorWithValuesAsOrtValue) as usize
                - ptr as usize
        },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateSparseTensorWithValuesAsOrtValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UseCooIndices) as usize - ptr as usize },
        1472usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(UseCooIndices))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UseCsrIndices) as usize - ptr as usize },
        1480usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(UseCsrIndices))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UseBlockSparseIndices) as usize - ptr as usize },
        1488usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(UseBlockSparseIndices))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSparseTensorFormat) as usize - ptr as usize },
        1496usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetSparseTensorFormat))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetSparseTensorValuesTypeAndShape) as usize - ptr as usize
        },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetSparseTensorValuesTypeAndShape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSparseTensorValues) as usize - ptr as usize },
        1512usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetSparseTensorValues))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetSparseTensorIndicesTypeShape) as usize - ptr as usize
        },
        1520usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetSparseTensorIndicesTypeShape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSparseTensorIndices) as usize - ptr as usize },
        1528usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetSparseTensorIndices))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HasValue) as usize - ptr as usize },
        1536usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(HasValue))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelContext_GetGPUComputeStream) as usize - ptr as usize
        },
        1544usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelContext_GetGPUComputeStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetTensorMemoryInfo) as usize - ptr as usize },
        1552usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetTensorMemoryInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetExecutionProviderApi) as usize - ptr as usize },
        1560usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetExecutionProviderApi))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsSetCustomCreateThreadFn) as usize
                - ptr as usize
        },
        1568usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsSetCustomCreateThreadFn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsSetCustomThreadCreationOptions) as usize
                - ptr as usize
        },
        1576usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsSetCustomThreadCreationOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsSetCustomJoinThreadFn) as usize - ptr as usize
        },
        1584usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsSetCustomJoinThreadFn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SetGlobalCustomCreateThreadFn) as usize - ptr as usize
        },
        1592usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetGlobalCustomCreateThreadFn)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SetGlobalCustomThreadCreationOptions) as usize
                - ptr as usize
        },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetGlobalCustomThreadCreationOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetGlobalCustomJoinThreadFn) as usize - ptr as usize },
        1608usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetGlobalCustomJoinThreadFn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SynchronizeBoundInputs) as usize - ptr as usize },
        1616usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SynchronizeBoundInputs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SynchronizeBoundOutputs) as usize - ptr as usize },
        1624usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SynchronizeBoundOutputs))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_CUDA_V2) as usize
                - ptr as usize
        },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_CUDA_V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateCUDAProviderOptions) as usize - ptr as usize },
        1640usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateCUDAProviderOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UpdateCUDAProviderOptions) as usize - ptr as usize },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(UpdateCUDAProviderOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetCUDAProviderOptionsAsString) as usize - ptr as usize
        },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetCUDAProviderOptionsAsString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseCUDAProviderOptions) as usize - ptr as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ReleaseCUDAProviderOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_MIGraphX) as usize
                - ptr as usize
        },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_MIGraphX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddExternalInitializers) as usize - ptr as usize },
        1680usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(AddExternalInitializers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateOpAttr) as usize - ptr as usize },
        1688usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateOpAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseOpAttr) as usize - ptr as usize },
        1696usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseOpAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateOp) as usize - ptr as usize },
        1704usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CreateOp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InvokeOp) as usize - ptr as usize },
        1712usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(InvokeOp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseOp) as usize - ptr as usize },
        1720usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseOp))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider) as usize
                - ptr as usize
        },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyKernelInfo) as usize - ptr as usize },
        1736usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(CopyKernelInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseKernelInfo) as usize - ptr as usize },
        1744usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReleaseKernelInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetTrainingApi) as usize - ptr as usize },
        1752usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetTrainingApi))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_CANN) as usize
                - ptr as usize
        },
        1760usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_CANN)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateCANNProviderOptions) as usize - ptr as usize },
        1768usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateCANNProviderOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UpdateCANNProviderOptions) as usize - ptr as usize },
        1776usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(UpdateCANNProviderOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetCANNProviderOptionsAsString) as usize - ptr as usize
        },
        1784usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetCANNProviderOptionsAsString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseCANNProviderOptions) as usize - ptr as usize },
        1792usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ReleaseCANNProviderOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemoryInfoGetDeviceType) as usize - ptr as usize },
        1800usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(MemoryInfoGetDeviceType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UpdateEnvWithCustomLogLevel) as usize - ptr as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(UpdateEnvWithCustomLogLevel)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SetGlobalIntraOpThreadAffinity) as usize - ptr as usize
        },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SetGlobalIntraOpThreadAffinity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegisterCustomOpsLibrary_V2) as usize - ptr as usize },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(RegisterCustomOpsLibrary_V2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).RegisterCustomOpsUsingFunction) as usize - ptr as usize
        },
        1832usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(RegisterCustomOpsUsingFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelInfo_GetInputCount) as usize - ptr as usize },
        1840usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfo_GetInputCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelInfo_GetOutputCount) as usize - ptr as usize },
        1848usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfo_GetOutputCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelInfo_GetInputName) as usize - ptr as usize },
        1856usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(KernelInfo_GetInputName))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelInfo_GetOutputName) as usize - ptr as usize },
        1864usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfo_GetOutputName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelInfo_GetInputTypeInfo) as usize - ptr as usize },
        1872usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfo_GetInputTypeInfo)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelInfo_GetOutputTypeInfo) as usize - ptr as usize
        },
        1880usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfo_GetOutputTypeInfo)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelInfoGetAttribute_tensor) as usize - ptr as usize
        },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfoGetAttribute_tensor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HasSessionConfigEntry) as usize - ptr as usize },
        1896usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(HasSessionConfigEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSessionConfigEntry) as usize - ptr as usize },
        1904usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetSessionConfigEntry))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_Dnnl) as usize
                - ptr as usize
        },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_Dnnl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateDnnlProviderOptions) as usize - ptr as usize },
        1920usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateDnnlProviderOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UpdateDnnlProviderOptions) as usize - ptr as usize },
        1928usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(UpdateDnnlProviderOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetDnnlProviderOptionsAsString) as usize - ptr as usize
        },
        1936usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetDnnlProviderOptionsAsString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseDnnlProviderOptions) as usize - ptr as usize },
        1944usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ReleaseDnnlProviderOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelInfo_GetNodeName) as usize - ptr as usize },
        1952usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(KernelInfo_GetNodeName))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelInfo_GetLogger) as usize - ptr as usize },
        1960usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(KernelInfo_GetLogger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelContext_GetLogger) as usize - ptr as usize },
        1968usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(KernelContext_GetLogger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Logger_LogMessage) as usize - ptr as usize },
        1976usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(Logger_LogMessage))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).Logger_GetLoggingSeverityLevel) as usize - ptr as usize
        },
        1984usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(Logger_GetLoggingSeverityLevel)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).KernelInfoGetConstantInput_tensor) as usize - ptr as usize
        },
        1992usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelInfoGetConstantInput_tensor)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CastTypeInfoToOptionalTypeInfo) as usize - ptr as usize
        },
        2000usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CastTypeInfoToOptionalTypeInfo)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetOptionalContainedTypeInfo) as usize - ptr as usize
        },
        2008usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetOptionalContainedTypeInfo)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetResizedStringTensorElementBuffer) as usize - ptr as usize
        },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetResizedStringTensorElementBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelContext_GetAllocator) as usize - ptr as usize },
        2024usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelContext_GetAllocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetBuildInfoString) as usize - ptr as usize },
        2032usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(GetBuildInfoString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateROCMProviderOptions) as usize - ptr as usize },
        2040usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateROCMProviderOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UpdateROCMProviderOptions) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(UpdateROCMProviderOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetROCMProviderOptionsAsString) as usize - ptr as usize
        },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetROCMProviderOptionsAsString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseROCMProviderOptions) as usize - ptr as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ReleaseROCMProviderOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CreateAndRegisterAllocatorV2) as usize - ptr as usize
        },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(CreateAndRegisterAllocatorV2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RunAsync) as usize - ptr as usize },
        2080usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(RunAsync))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).UpdateTensorRTProviderOptionsWithValue) as usize
                - ptr as usize
        },
        2088usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(UpdateTensorRTProviderOptionsWithValue)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetTensorRTProviderOptionsByName) as usize - ptr as usize
        },
        2096usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetTensorRTProviderOptionsByName)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).UpdateCUDAProviderOptionsWithValue) as usize - ptr as usize
        },
        2104usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(UpdateCUDAProviderOptionsWithValue)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetCUDAProviderOptionsByName) as usize - ptr as usize
        },
        2112usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(GetCUDAProviderOptionsByName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelContext_GetResource) as usize - ptr as usize },
        2120usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelContext_GetResource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetUserLoggingFunction) as usize - ptr as usize },
        2128usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetUserLoggingFunction))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ShapeInferContext_GetInputCount) as usize - ptr as usize
        },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ShapeInferContext_GetInputCount)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ShapeInferContext_GetInputTypeShape) as usize - ptr as usize
        },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ShapeInferContext_GetInputTypeShape)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ShapeInferContext_GetAttribute) as usize - ptr as usize
        },
        2152usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ShapeInferContext_GetAttribute)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ShapeInferContext_SetOutputTypeShape) as usize
                - ptr as usize
        },
        2160usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(ShapeInferContext_SetOutputTypeShape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetSymbolicDimensions) as usize - ptr as usize },
        2168usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetSymbolicDimensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadOpAttr) as usize - ptr as usize },
        2176usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(ReadOpAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetDeterministicCompute) as usize - ptr as usize },
        2184usize,
        concat!("Offset of field: ", stringify!(OrtApi), "::", stringify!(SetDeterministicCompute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelContext_ParallelFor) as usize - ptr as usize },
        2192usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(KernelContext_ParallelFor)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SessionOptionsAppendExecutionProvider_OpenVINO_V2) as usize
                - ptr as usize
        },
        2200usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtApi),
            "::",
            stringify!(SessionOptionsAppendExecutionProvider_OpenVINO_V2)
        )
    );
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OrtCustomOpInputOutputCharacteristic {
    INPUT_OUTPUT_REQUIRED = 0,
    INPUT_OUTPUT_OPTIONAL = 1,
    INPUT_OUTPUT_VARIADIC = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OrtCustomOp {
    pub version: u32,
    pub CreateKernel: ::std::option::Option<
        unsafe extern "C" fn(
            op: *const OrtCustomOp,
            api: *const OrtApi,
            info: *const OrtKernelInfo,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub GetName: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp) -> *const ::std::os::raw::c_char,
    >,
    pub GetExecutionProviderType: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp) -> *const ::std::os::raw::c_char,
    >,
    pub GetInputType: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp, index: usize) -> ONNXTensorElementDataType,
    >,
    pub GetInputTypeCount:
        ::std::option::Option<unsafe extern "C" fn(op: *const OrtCustomOp) -> usize>,
    pub GetOutputType: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp, index: usize) -> ONNXTensorElementDataType,
    >,
    pub GetOutputTypeCount:
        ::std::option::Option<unsafe extern "C" fn(op: *const OrtCustomOp) -> usize>,
    pub KernelCompute: ::std::option::Option<
        unsafe extern "C" fn(
            op_kernel: *mut ::std::os::raw::c_void,
            context: *mut OrtKernelContext,
        ),
    >,
    pub KernelDestroy:
        ::std::option::Option<unsafe extern "C" fn(op_kernel: *mut ::std::os::raw::c_void)>,
    pub GetInputCharacteristic: ::std::option::Option<
        unsafe extern "C" fn(
            op: *const OrtCustomOp,
            index: usize,
        ) -> OrtCustomOpInputOutputCharacteristic,
    >,
    pub GetOutputCharacteristic: ::std::option::Option<
        unsafe extern "C" fn(
            op: *const OrtCustomOp,
            index: usize,
        ) -> OrtCustomOpInputOutputCharacteristic,
    >,
    pub GetInputMemoryType: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp, index: usize) -> OrtMemType,
    >,
    pub GetVariadicInputMinArity: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp) -> ::std::os::raw::c_int,
    >,
    pub GetVariadicInputHomogeneity: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp) -> ::std::os::raw::c_int,
    >,
    pub GetVariadicOutputMinArity: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp) -> ::std::os::raw::c_int,
    >,
    pub GetVariadicOutputHomogeneity: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp) -> ::std::os::raw::c_int,
    >,
    pub CreateKernelV2: ::std::option::Option<
        unsafe extern "C" fn(
            op: *const OrtCustomOp,
            api: *const OrtApi,
            info: *const OrtKernelInfo,
            kernel: *mut *mut ::std::os::raw::c_void,
        ) -> OrtStatusPtr,
    >,
    pub KernelComputeV2: ::std::option::Option<
        unsafe extern "C" fn(
            op_kernel: *mut ::std::os::raw::c_void,
            context: *mut OrtKernelContext,
        ) -> OrtStatusPtr,
    >,
    pub InferOutputShapeFn: ::std::option::Option<
        unsafe extern "C" fn(
            op: *const OrtCustomOp,
            arg1: *mut OrtShapeInferContext,
        ) -> OrtStatusPtr,
    >,
    pub GetStartVersion: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp) -> ::std::os::raw::c_int,
    >,
    pub GetEndVersion: ::std::option::Option<
        unsafe extern "C" fn(op: *const OrtCustomOp) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_OrtCustomOp() {
    const UNINIT: ::std::mem::MaybeUninit<OrtCustomOp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OrtCustomOp>(),
        176usize,
        concat!("Size of: ", stringify!(OrtCustomOp))
    );
    assert_eq!(
        ::std::mem::align_of::<OrtCustomOp>(),
        8usize,
        concat!("Alignment of ", stringify!(OrtCustomOp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(version))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateKernel) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(CreateKernel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetName) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(GetName))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetExecutionProviderType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCustomOp),
            "::",
            stringify!(GetExecutionProviderType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetInputType) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(GetInputType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetInputTypeCount) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(GetInputTypeCount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetOutputType) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(GetOutputType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetOutputTypeCount) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(GetOutputTypeCount))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelCompute) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(KernelCompute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelDestroy) as usize - ptr as usize },
        72usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(KernelDestroy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetInputCharacteristic) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCustomOp),
            "::",
            stringify!(GetInputCharacteristic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetOutputCharacteristic) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCustomOp),
            "::",
            stringify!(GetOutputCharacteristic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetInputMemoryType) as usize - ptr as usize },
        96usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(GetInputMemoryType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetVariadicInputMinArity) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCustomOp),
            "::",
            stringify!(GetVariadicInputMinArity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetVariadicInputHomogeneity) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCustomOp),
            "::",
            stringify!(GetVariadicInputHomogeneity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetVariadicOutputMinArity) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCustomOp),
            "::",
            stringify!(GetVariadicOutputMinArity)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).GetVariadicOutputHomogeneity) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(OrtCustomOp),
            "::",
            stringify!(GetVariadicOutputHomogeneity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateKernelV2) as usize - ptr as usize },
        136usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(CreateKernelV2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelComputeV2) as usize - ptr as usize },
        144usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(KernelComputeV2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InferOutputShapeFn) as usize - ptr as usize },
        152usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(InferOutputShapeFn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetStartVersion) as usize - ptr as usize },
        160usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(GetStartVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetEndVersion) as usize - ptr as usize },
        168usize,
        concat!("Offset of field: ", stringify!(OrtCustomOp), "::", stringify!(GetEndVersion))
    );
}
extern "C" {
    pub fn OrtSessionOptionsAppendExecutionProvider_CUDA(
        options: *mut OrtSessionOptions,
        device_id: ::std::os::raw::c_int,
    ) -> OrtStatusPtr;
}
extern "C" {
    pub fn OrtSessionOptionsAppendExecutionProvider_ROCM(
        options: *mut OrtSessionOptions,
        device_id: ::std::os::raw::c_int,
    ) -> OrtStatusPtr;
}
extern "C" {
    pub fn OrtSessionOptionsAppendExecutionProvider_MIGraphX(
        options: *mut OrtSessionOptions,
        device_id: ::std::os::raw::c_int,
    ) -> OrtStatusPtr;
}
extern "C" {
    pub fn OrtSessionOptionsAppendExecutionProvider_Dnnl(
        options: *mut OrtSessionOptions,
        use_arena: ::std::os::raw::c_int,
    ) -> OrtStatusPtr;
}
extern "C" {
    pub fn OrtSessionOptionsAppendExecutionProvider_Tensorrt(
        options: *mut OrtSessionOptions,
        device_id: ::std::os::raw::c_int,
    ) -> OrtStatusPtr;
}
extern "C" {
    #[doc = " \\param use_arena zero: false. non-zero: true."]
    pub fn OrtSessionOptionsAppendExecutionProvider_CPU(
        options: *mut OrtSessionOptions,
        use_arena: ::std::os::raw::c_int,
    ) -> OrtStatusPtr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
